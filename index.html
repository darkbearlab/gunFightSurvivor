<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç¾…è³“æ¼¢æˆ°è¨˜ - Phase 7 (Fixed Movement)</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
    <style>
        body { margin: 0; padding: 0; background-color: #2d2d2d; overflow: hidden; font-family: 'Segoe UI', sans-serif; user-select: none; }
        #game-container { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; }
        
        #ui-layer {
            position: absolute; top: 20px; left: 20px; color: white; pointer-events: none;
            text-shadow: 1px 1px 2px black; background-color: rgba(0, 0, 0, 0.7); padding: 15px; border-radius: 8px; max-width: 320px; z-index: 10;
        }
        
        #game-over-screen {
            display: none; position: absolute; top: 0; left: 0; width: 100vw; height: 100vh;
            background: rgba(0,0,0,0.85); color: white; z-index: 20;
            flex-direction: column; justify-content: center; align-items: center; text-align: center;
        }
        #game-over-title { font-size: 3em; margin-bottom: 20px; font-weight: bold; }
        button { margin-top: 30px; padding: 10px 30px; font-size: 1.5em; cursor: pointer; background: gold; border: none; border-radius: 5px; }
        
        .stat-row { display: flex; justify-content: space-between; margin-bottom: 5px; }
        .key { color: yellow; font-weight: bold; }
        .bar-container { width: 100%; background: #444; height: 10px; border-radius: 5px; margin-top: 5px; overflow: hidden; }
        .bar-fill { height: 100%; background: lime; width: 0%; transition: width 0.5s; }
    </style>
</head>
<body>

<div id="ui-layer">
    <div class="stat-row">
        <span>æ™‚é–“: <span id="time-display" style="color: cyan; font-weight:bold;">05:00</span></span>
        <span>é‡‘éŒ¢: $<span id="gold-display" style="color: gold;">0</span></span>
    </div>
    
    <div style="margin-top: 10px;">
        åè²: <span id="rep-display">0</span> / 3000
        <div class="bar-container"><div id="rep-bar" class="bar-fill"></div></div>
    </div>
    
    <hr>
    <p><span class="key">Space</span> åˆ‡æ›æ¨¡å¼ | <span class="key">U</span> å‡ç´šæ‘èŠ</p>
    <p><span class="key">H</span> æ‹›å‹Ÿæ­¥å…µ | <span class="key">J</span> æ‹›å‹Ÿå¼“æ‰‹</p>
    <hr>
    <p>æ¨¡å¼: <span id="mode-indicator" style="color: lime;">ğŸ›¡ï¸ è·Ÿéš¨</span></p>
    <p>éƒ¨éšŠ: <span id="squad-count">0</span> | æ•µè»: <span id="enemy-count">0</span></p>
</div>

<div id="game-over-screen">
    <div id="game-over-title">GAME OVER</div>
    <div id="game-over-desc"></div>
    <button onclick="location.reload()">å†ç©ä¸€æ¬¡</button>
</div>

<div id="game-container"></div>

<script>
// --- å…¨åŸŸè¨­å®š ---
const GAME_DURATION = 300; 
const TARGET_REP = 3000;

// è®Šæ•¸
let game, player, director;
let gold = 300; 
let reputation = 0;
let isAutoAttackMode = false;
let gameTimeLeft = GAME_DURATION;
let isGameOver = false;

// ç¾¤çµ„
let squad, enemies, wildLife, obstacles, projectiles;
let villages = [];
let uiTexts = {}; 

// è¼¸å…¥
let cursors, wasd, keys;

// --- è¼”åŠ©å‡½å¼ ---
function updateGold(amount) {
    gold += amount;
    uiTexts.gold.innerText = gold;
}

function updateRep(amount) {
    reputation += amount;
    if (reputation < 0) reputation = 0;
    uiTexts.rep.innerText = Math.floor(reputation);
    let pct = Math.min((reputation / TARGET_REP) * 100, 100);
    uiTexts.repBar.style.width = pct + "%";
}

function showDamageText(scene, x, y, amount, color = '#fff') {
    let text = scene.add.text(x, y - 20, amount, {
        fontSize: '16px', color: color, stroke: '#000', strokeThickness: 3, fontWeight: 'bold'
    }).setOrigin(0.5);
    scene.tweens.add({ targets: text, y: y - 50, alpha: 0, duration: 800, onComplete: () => text.destroy() });
}

function showToast(scene, msg, color) {
    let text = scene.add.text(player.x, player.y - 150, msg, {
        fontSize: '24px', color: color, stroke: '#000', strokeThickness: 4, backgroundColor: 'rgba(0,0,0,0.6)', padding: {x:10, y:5}
    }).setOrigin(0.5).setDepth(100);
    scene.tweens.add({ targets: text, y: player.y - 200, alpha: 0, duration: 3000, onComplete: () => text.destroy() });
}

function checkGameOver() {
    if (isGameOver) return;
    if (gameTimeLeft <= 0) {
        if (reputation >= TARGET_REP) endGame(true, "å‚³å¥‡èª•ç”Ÿï¼<br>ä½ æˆåŠŸæŠµæŠ—äº†æš´æ”¿ï¼Œä¸¦å»ºç«‹äº†æ–°çš„ç§©åºã€‚");
        else endGame(false, "èµ·ç¾©å¤±æ•—ã€‚<br>éš¨è‘—ç…å¿ƒç‹æ­¸åœ‹ï¼Œä½ çš„åå­—è¢«éºå¿˜åœ¨æ­·å²ä¸­ã€‚");
    }
}

function endGame(victory, message) {
    isGameOver = true;
    game.scene.pause("default");
    const screen = document.getElementById('game-over-screen');
    const title = document.getElementById('game-over-title');
    const desc = document.getElementById('game-over-desc');
    screen.style.display = 'flex';
    title.innerText = victory ? "VICTORY!" : "DEFEAT";
    title.style.color = victory ? "gold" : "red";
    desc.innerHTML = message;
}

// --- å–®ä½é¡åˆ¥ ---

class Unit extends Phaser.GameObjects.Rectangle {
    constructor(scene, x, y, width, height, color, hp, maxHp) {
        super(scene, x, y, width, height, color);
        scene.add.existing(this);
        scene.physics.add.existing(this);
        this.hp = hp;
        this.maxHp = maxHp || hp;
        this.isDead = false;
        this.lastAttackTime = 0;
        
        // è¡€æ¢
        this.hpBarBg = scene.add.rectangle(x, y - height, width, 4, 0x000000).setDepth(1);
        this.hpBar = scene.add.rectangle(x, y - height, width, 4, 0x00ff00).setDepth(1);
    }

    preUpdate() {
        if (this.isDead) return;
        this.hpBarBg.setPosition(this.x, this.y - this.height/2 - 5);
        this.hpBar.setPosition(this.x, this.y - this.height/2 - 5);
    }

    takeDamage(amount) {
        if (this.isDead) return;
        this.scene.tweens.add({ targets: this, alpha: 0.2, duration: 50, yoyo: true, repeat: 1 });
        this.hp -= amount;
        
        showDamageText(this.scene, this.x, this.y, amount);

        const pct = Math.max(0, this.hp / this.maxHp);
        this.hpBar.width = this.width * pct;
        if (pct < 0.3) this.hpBar.fillColor = 0xff0000;
        else if (pct < 0.6) this.hpBar.fillColor = 0xffff00;

        if (this.hp <= 0) this.die();
    }

    die() {
        this.isDead = true;
        this.hpBar.destroy();
        this.hpBarBg.destroy();
        const particles = this.scene.add.particles(this.x, this.y, 'pixel', { speed: 100, scale: { start: 1, end: 0 }, lifespan: 500, blendMode: 'ADD', tint: this.fillColor });
        this.scene.time.delayedCall(500, () => particles.destroy());
        this.destroy();
    }
}

// --- æŠ•å°„ç‰©ç³»çµ± ---
class Projectile extends Phaser.GameObjects.Rectangle {
    constructor(scene, x, y, target, damage, isEnemy, speed, lifeTime, color) {
        super(scene, x, y, 10, 4, color || (isEnemy ? 0xff4444 : 0xffff00));
        scene.add.existing(this);
        scene.physics.add.existing(this);
        this.damage = damage;
        this.isEnemy = isEnemy;
        this.bornTime = Date.now();
        this.lifeTime = lifeTime || 1000;
        
        const angle = Phaser.Math.Angle.Between(x, y, target.x, target.y);
        this.rotation = angle;
        scene.physics.velocityFromRotation(angle, speed || 400, this.body.velocity);
    }
    update() { if (Date.now() - this.bornTime > this.lifeTime) this.destroy(); }
}

class MeleeSlash extends Projectile {
    constructor(scene, x, y, target, damage, isEnemy) {
        super(scene, x, y, target, damage, isEnemy, 600, 150, 0xffffff);
        this.width = 16; this.height = 16; 
        scene.tweens.add({
            targets: this,
            scaleX: 1.5, scaleY: 1.5, alpha: 0,
            duration: 150
        });
    }
}

// --- è‹±é›„ (æ”¹ç‚º Sprite) ---
class Hero extends Phaser.Physics.Arcade.Sprite {
    constructor(scene, x, y) {
        // å˜—è©¦ä½¿ç”¨ 'player' è²¼åœ–ï¼Œå¦‚æœæ²’è¼‰å…¥æˆåŠŸ (ä¾‹å¦‚åœ¨ file:// ç’°å¢ƒ)ï¼ŒPhaser æœƒé¡¯ç¤ºç¶ è‰²/é»‘è‰²ç¼ºåœ–æ¡†
        // æˆ‘å€‘å¯ä»¥åœ¨ create è£¡åšè£œæ•‘ï¼Œæˆ–è€…åœ¨é€™è£¡æª¢æŸ¥ texture
        super(scene, x, y, 'player');
        
        scene.add.existing(this);
        scene.physics.add.existing(this);
        
        // è¦–è¦ºèª¿æ•´
        this.setScale(0.5); 
        
        // ç‰©ç†èª¿æ•´
        this.body.setCollideWorldBounds(true);
        this.body.pushable = false;
        this.body.setSize(24, 24); 
        
        // å±¬æ€§è¤‡è£½è‡ª Unit
        this.hp = 300;
        this.maxHp = 300;
        this.isDead = false;
        this.lastAttackTime = 0;
        this.lastDamageTime = 0;
        
        this.speed = 220;
        this.detectRange = 100; 
        this.attackCooldown = 500;
        
        // è¡€æ¢
        this.hpBarBg = scene.add.rectangle(x, y - 30, 40, 4, 0x000000).setDepth(1);
        this.hpBar = scene.add.rectangle(x, y - 30, 40, 4, 0x00ff00).setDepth(1);
    }
    
    preUpdate(time, delta) {
        super.preUpdate(time, delta);
        if (this.isDead) return;
        this.hpBarBg.setPosition(this.x, this.y - 30);
        this.hpBar.setPosition(this.x, this.y - 30);
    }

    move() {
        this.body.setVelocity(0);
        if (cursors.left.isDown || wasd.left.isDown) this.body.setVelocityX(-this.speed);
        else if (cursors.right.isDown || wasd.right.isDown) this.body.setVelocityX(this.speed);
        if (cursors.up.isDown || wasd.up.isDown) this.body.setVelocityY(-this.speed);
        else if (cursors.down.isDown || wasd.down.isDown) this.body.setVelocityY(this.speed);
        this.body.velocity.normalize().scale(this.speed);
    }
    
    update() {
        if(this.isDead) return;
        this.move();
        
        if (Date.now() - this.lastAttackTime > this.attackCooldown) {
            let target = this.findTarget(enemies, this.detectRange);
            if (!target) target = this.findTarget(wildLife, this.detectRange);
            if (target) {
                projectiles.add(new MeleeSlash(this.scene, this.x, this.y, target, 25, false));
                this.lastAttackTime = Date.now();
            }
        }
    }
    
    findTarget(group, range) {
        let target = null; let minDist = range;
        group.children.iterate(u => { 
            if (u && !u.isDead && u.body) { 
                let d = Phaser.Math.Distance.Between(this.x, this.y, u.x, u.y); 
                if (d < minDist) { minDist = d; target = u; } 
            } 
        });
        return target;
    }
    
    takeDamage(amount) {
        if (this.isDead) return;
        this.scene.tweens.add({ targets: this, alpha: 0.2, duration: 50, yoyo: true, repeat: 1 });
        this.hp -= amount;
        showDamageText(this.scene, this.x, this.y, amount);
        const pct = Math.max(0, this.hp / this.maxHp);
        this.hpBar.width = 40 * pct;
        if (pct < 0.3) this.hpBar.fillColor = 0xff0000;
        else if (pct < 0.6) this.hpBar.fillColor = 0xffff00;
        if (this.hp <= 0) this.die();
    }

    die() {
        this.isDead = true;
        this.hpBar.destroy(); this.hpBarBg.destroy();
        this.destroy();
        endGame(false, "ä½ æˆ°æ­»æ²™å ´ï¼Œé©å‘½ä¹‹ç«ç†„æ»…äº†ã€‚");
    }
}

// --- å£«å…µé¡åˆ¥ (ç©å®¶) ---
class Soldier extends Unit {
    constructor(scene, x, y) {
        super(scene, x, y, 20, 20, 0x33ccff, 60, 60); 
        this.speed = 180;
        this.detectRange = 300;
        this.guardRange = 120;
        this.attackRange = 40; 
        this.wanderOffset = new Phaser.Math.Vector2(Phaser.Math.Between(-50,50), Phaser.Math.Between(-50,50));
    }
    update(player, isAutoMode) {
        if(this.isDead) return;
        this.preUpdate();
        
        if (!isAutoMode) {
            this.follow(player, false);
            return; 
        }
        
        let target = this.findTarget(enemies, this.detectRange);
        if (!target && isAutoMode) target = this.findTarget(wildLife, this.detectRange);

        if (target) {
            let dist = Phaser.Math.Distance.Between(this.x, this.y, target.x, target.y);
            if (dist <= this.attackRange) {
                this.body.setVelocity(0);
                if (Date.now() - this.lastAttackTime > 800) { 
                    projectiles.add(new MeleeSlash(this.scene, this.x, this.y, target, 15, false));
                    this.lastAttackTime = Date.now();
                }
            } else {
                this.scene.physics.moveToObject(this, target, this.speed * 1.2);
            }
        } else {
            this.follow(player, isAutoMode);
        }
    }
    findTarget(group, range) {
        let target = null; let minDist = range;
        group.children.iterate(u => { if (u && !u.isDead && u.body) { let d = Phaser.Math.Distance.Between(this.x, this.y, u.x, u.y); if (d < minDist) { minDist = d; target = u; } } });
        return target;
    }
    follow(player, isAutoMode) {
        let d = Phaser.Math.Distance.Between(this.x, this.y, player.x, player.y);
        if (d > 60) this.scene.physics.moveTo(this, player.x + this.wanderOffset.x, player.y + this.wanderOffset.y, this.speed);
        else this.body.setVelocity(0);
    }
}

class Archer extends Unit {
    constructor(scene, x, y) {
        super(scene, x, y, 16, 16, 0x00ffff, 30, 30);
        this.speed = 160;
        this.detectRange = 350;
        this.attackRange = 180;
        this.wanderOffset = new Phaser.Math.Vector2(Phaser.Math.Between(-50,50), Phaser.Math.Between(-50,50));
    }
    update(player, isAutoMode) {
        if(this.isDead) return;
        this.preUpdate();
        
        if (!isAutoMode) {
            this.follow(player, false);
            return; 
        }
        
        let target = this.findTarget(enemies, this.detectRange);
        if (!target && isAutoMode) target = this.findTarget(wildLife, this.detectRange);

        if (target) {
            let d = Phaser.Math.Distance.Between(this.x, this.y, target.x, target.y);
            if (d > this.attackRange) {
                this.scene.physics.moveToObject(this, target, this.speed);
            } else {
                this.body.setVelocity(0);
                if (Date.now() - this.lastAttackTime > 1200) {
                    projectiles.add(new Projectile(this.scene, this.x, this.y, target, 15, false));
                    this.lastAttackTime = Date.now();
                }
            }
        } else {
            this.follow(player, isAutoMode);
        }
    }
    
    findTarget(group, range) { 
        let target = null; 
        let minDist = range;
        group.children.iterate(u => { 
            if (u && !u.isDead && u.body) { 
                let d = Phaser.Math.Distance.Between(this.x, this.y, u.x, u.y); 
                if (d < minDist) { minDist = d; target = u; } 
            } 
        });
        return target;
    }
    
    follow(player, isAutoMode) { 
        let d = Phaser.Math.Distance.Between(this.x, this.y, player.x, player.y);
        // ä¸€èˆ¬è·Ÿéš¨
        if (d > 70) this.scene.physics.moveTo(this, player.x + this.wanderOffset.x, player.y + this.wanderOffset.y, this.speed);
        else this.body.setVelocity(0);
    }
}

// --- æ•µäººå–®ä½ ---
class EnemyUnit extends Unit {
    constructor(scene, x, y, color, hp, speed, target) {
        super(scene, x, y, 20, 20, color, hp, hp);
        this.moveTarget = target; 
        this.speed = speed;
        this.attackRange = 40; 
    }
    
    findAggroTarget() {
        let target = null;
        let minDist = 200; 
        
        let d = Phaser.Math.Distance.Between(this.x, this.y, player.x, player.y);
        if (d < minDist) { minDist = d; target = player; }
        
        squad.children.iterate(s => {
            if(s && !s.isDead) {
                let sd = Phaser.Math.Distance.Between(this.x, this.y, s.x, s.y);
                if (sd < minDist) { minDist = sd; target = s; }
            }
        });
        return target;
    }
}

class EnemySoldier extends EnemyUnit {
    constructor(scene, x, y, target) {
        super(scene, x, y, 0xff4444, 60, 130, target);
    }
    update() {
        if(this.isDead) return;
        this.preUpdate();
        
        let combatTarget = this.findAggroTarget();
        let finalTarget = combatTarget || this.moveTarget;
        
        if (this.moveTarget instanceof Village) {
             let distToVillage = Phaser.Math.Distance.Between(this.x, this.y, this.moveTarget.x, this.moveTarget.y);
             if (distToVillage < this.moveTarget.siegeRadius) {
                 if (!combatTarget) { this.body.setVelocity(0); return; }
             }
        }
        
        if (finalTarget && !finalTarget.isDead) {
            let dist = Phaser.Math.Distance.Between(this.x, this.y, finalTarget.x, finalTarget.y);
            if (dist <= this.attackRange) {
                this.body.setVelocity(0);
                if (Date.now() - this.lastAttackTime > 1000) {
                    projectiles.add(new MeleeSlash(this.scene, this.x, this.y, finalTarget, 10, true));
                    this.lastAttackTime = Date.now();
                }
            }
            else this.scene.physics.moveToObject(this, finalTarget, this.speed);
        }
    }
}

class EnemyArcher extends EnemyUnit {
    constructor(scene, x, y, target) {
        super(scene, x, y, 0xff8888, 40, 110, target); 
        this.attackRange = 180;
    }
    update() {
        if(this.isDead) return;
        this.preUpdate();
        
        let combatTarget = this.findAggroTarget();
        let finalTarget = combatTarget || this.moveTarget;
        
        if (!combatTarget && this.moveTarget instanceof Village) {
             let distToVillage = Phaser.Math.Distance.Between(this.x, this.y, this.moveTarget.x, this.moveTarget.y);
             if (distToVillage < this.moveTarget.siegeRadius) { this.body.setVelocity(0); return; }
        }

        if (finalTarget && !finalTarget.isDead) {
            let dist = Phaser.Math.Distance.Between(this.x, this.y, finalTarget.x, finalTarget.y);
            if (dist > this.attackRange) {
                this.scene.physics.moveToObject(this, finalTarget, this.speed);
            } else {
                this.body.setVelocity(0);
                if (Date.now() - this.lastAttackTime > 1500) {
                    projectiles.add(new Projectile(this.scene, this.x, this.y, finalTarget, 10, true));
                    this.lastAttackTime = Date.now();
                }
            }
        }
    }
}

class Carriage extends EnemyUnit {
    constructor(scene, startX, startY, endX, endY) {
        super(scene, startX, startY, 0xffd700, 300, 30, null);
        this.width = 40; this.height = 60;
        this.targetPos = new Phaser.Math.Vector2(endX, endY);
        this.body.setCollideWorldBounds(true);
        this.body.setImmovable(true);
        this.scene.physics.moveTo(this, endX, endY, this.speed);
        this.hpBarBg.destroy(); this.hpBar.destroy();
        this.hpBarBg = scene.add.rectangle(this.x, this.y, 40, 4, 0x000000).setDepth(1);
        this.hpBar = scene.add.rectangle(this.x, this.y, 40, 4, 0x00ff00).setDepth(1);
    }
    die() {
        updateGold(600); updateRep(150);
        showToast(this.scene, "æ¶å¾— $600 + 150 Rep!", "gold"); super.die();
    }
}

// --- é‡ç”Ÿå‹•ç‰© ---
class Deer extends Unit {
    constructor(scene, x, y) { super(scene, x, y, 16, 16, 0xc2b280, 15); this.speed=40; this.timer=0; this.body.setCollideWorldBounds(true); }
    update() { if(this.isDead)return; this.preUpdate(); this.timer++; if(this.timer>100){ if(Math.random()>0.3) this.scene.physics.velocityFromAngle(Phaser.Math.Between(0,360),40,this.body.velocity); else this.body.setVelocity(0); this.timer=0; } }
    die() { updateGold(15); super.die(); }
}

class Wolf extends Unit {
    constructor(scene, x, y) { super(scene, x, y, 20, 20, 0x808080, 40); this.speed=100; this.body.setCollideWorldBounds(true); this.attackRange = 40; }
    update() { 
        if(this.isDead)return; this.preUpdate(); 
        let target = null; let minDist = 200;
        let d = Phaser.Math.Distance.Between(this.x, this.y, player.x, player.y);
        if (d < minDist) { minDist = d; target = player; }
        squad.children.iterate(s => { if(s && !s.isDead) { let sd = Phaser.Math.Distance.Between(this.x, this.y, s.x, s.y); if (sd < minDist) { minDist = sd; target = s; } } });
        wildLife.children.iterate(w => { if(w instanceof Deer && !w.isDead) { let wd = Phaser.Math.Distance.Between(this.x, this.y, w.x, w.y); if (wd < minDist) { minDist = wd; target = w; } } });
        
        if (target) {
            if (minDist <= this.attackRange) {
                this.body.setVelocity(0);
                if (Date.now() - this.lastAttackTime > 1000) {
                    projectiles.add(new MeleeSlash(this.scene, this.x, this.y, target, 10, true));
                    this.lastAttackTime = Date.now();
                }
            } else this.scene.physics.moveToObject(this, target, this.speed);
        } else {
             if (Math.random() < 0.02) this.scene.physics.velocityFromAngle(Phaser.Math.Between(0,360), 50, this.body.velocity);
        }
    }
    die() { updateGold(25); super.die(); }
}

// --- æ‘èŠèˆ‡å°æ¼” ---
class Village {
    constructor(scene, x, y, name) {
        this.scene = scene; this.x = x; this.y = y; this.name = name;
        this.level = 1; this.stock = 3; this.maxStock = 3; this.passiveTimer = 0; this.stockTimer = 0;
        this.siegeRadius = 90; this.integrity = 100; this.maxIntegrity = 100;
        this.siegeZone = scene.add.circle(x, y, this.siegeRadius, 0xff0000, 0.1); scene.physics.add.existing(this.siegeZone, true);
        this.building = scene.add.rectangle(x, y, 60, 60, 0x8b4513); scene.physics.add.existing(this.building, true); obstacles.add(this.building);
        this.interactZone = scene.add.circle(x, y, 50, 0xffff00, 0.2);
        this.nameText = scene.add.text(x, y - 50, name, {fontSize: '16px', fontWeight:'bold'}).setOrigin(0.5);
        this.levelText = scene.add.text(x, y - 35, "Lv.1", {fontSize: '14px', color:'#aaa'}).setOrigin(0.5);
        this.siegeBar = scene.add.rectangle(x, y + 40, 60, 6, 0x00ff00).setOrigin(0.5);
    }
    update(delta, enemies) {
        let siegeCount = 0;
        enemies.children.iterate(e => { if (e && !e.isDead && Phaser.Math.Distance.Between(this.x, this.y, e.x, e.y) < this.siegeRadius) siegeCount++; });
        if (siegeCount > 0 && this.level > 1) {
            this.integrity -= siegeCount * (delta/1000) * 5;
            if (this.integrity <= 0) this.downgrade();
            this.siegeZone.fillColor = 0xff0000; this.siegeZone.fillAlpha = 0.3;
        } else {
            if (this.integrity < this.maxIntegrity) this.integrity += (delta/1000) * 2;
            this.siegeZone.fillColor = 0x000000; this.siegeZone.fillAlpha = 0.05;
        }
        this.siegeBar.width = 60 * (this.integrity / this.maxIntegrity);
        this.siegeBar.fillColor = (siegeCount > 0) ? 0xff0000 : 0x00ff00;
        if (this.level > 1) {
            this.passiveTimer += delta;
            if (this.passiveTimer > 5000) { let income = (this.level - 1) * 5; updateRep(income); this.passiveTimer = 0; }
        }
        if (this.stock < this.maxStock) { this.stockTimer += delta; if (this.stockTimer > 6000) { this.stock++; this.stockTimer = 0; } }
    }
    upgrade() {
        if (this.level >= 5) return false;
        let cost = this.level * 100;
        if (gold >= cost) {
            updateGold(-cost); this.level++; this.integrity = 100; this.maxStock = 2 + this.level; this.stock = this.maxStock;
            this.refreshVisuals(); showToast(this.scene, `${this.name} å‡ç´šè‡³ Lv.${this.level}!`, "cyan"); return true;
        } return false;
    }
    downgrade() { this.level = 1; this.integrity = 100; updateRep(-200); showToast(this.scene, `${this.name} è¢«æ”»é™·äº†ï¼`, "red"); this.refreshVisuals(); }
    recruit(type) { if (this.stock <= 0) return false; let cost = (type === 'H') ? 20 : 30; if (gold >= cost) { updateGold(-cost); this.stock--; return true; } return false; }
    refreshVisuals() { this.levelText.setText(`Lv.${this.level}`); let colors = [0x8b4513, 0xcd853f, 0xd2691e, 0xa0522d, 0x800000]; this.building.fillColor = colors[this.level-1] || 0x8b4513; }
}

class GameDirector {
    constructor(scene) { this.scene = scene; this.timers = { patrol: 0, caravan: 0 }; }
    update(delta) {
        if (isGameOver) return;
        this.timers.patrol += delta; this.timers.caravan += delta;
        let timeFactor = (300 - gameTimeLeft) / 60; let repFactor = reputation / 500;
        let difficulty = 1 + (timeFactor * 0.5) + (repFactor * 0.5);
        let patrolInterval = Math.max(10000, 40000 - (difficulty * 4000));
        if (this.timers.patrol > patrolInterval) { this.spawnPatrol(difficulty); this.timers.patrol = 0; }
        if (this.timers.caravan > 35000) { this.spawnCaravan(difficulty); this.timers.caravan = 0; }
    }
    spawnPatrol(difficulty) {
        let targets = [player]; villages.forEach(v => { if(v.level > 1) targets.push(v); });
        let target = targets[Phaser.Math.Between(0, targets.length-1)];
        let msg = (target === player) ? "å·¡é‚éšŠæ­£åœ¨æœæ•ä½ ï¼" : `å·¡é‚éšŠæ­£åœ¨å‰å¾€ ${target.name}ï¼`;
        showToast(this.scene, msg, "red");
        let count = Math.floor(2 + difficulty); let pos = getRandomEdgePos(this.scene, 100);
        for(let i=0; i<count; i++) {
            let px = pos.x + Phaser.Math.Between(-30,30); let py = pos.y + Phaser.Math.Between(-30,30);
            if (Math.random() < 0.3) enemies.add(new EnemyArcher(this.scene, px, py, target)); else enemies.add(new EnemySoldier(this.scene, px, py, target));
        }
    }
    spawnCaravan(difficulty) {
        let startX, startY, endX, endY; if (Math.random() > 0.5) { startX = 50; startY = Phaser.Math.Between(200, 1800); endX = 1950; endY = Phaser.Math.Between(200, 1800); } else { startX = Phaser.Math.Between(200, 1800); startY = 50; endX = Phaser.Math.Between(200, 1800); endY = 1950; }
        let carriage = new Carriage(this.scene, startX, startY, endX, endY); enemies.add(carriage);
        let guardCount = Math.floor(2 + difficulty);
        for(let i=0; i<guardCount; i++) {
            let px = startX + Phaser.Math.Between(-30,30); let py = startY + Phaser.Math.Between(-30,30);
            if (Math.random() < 0.3) enemies.add(new EnemyArcher(this.scene, px, py, player)); else enemies.add(new EnemySoldier(this.scene, px, py, player));
        }
    }
}

// --- Main Setup ---
const config = {
    type: Phaser.AUTO, width: window.innerWidth, height: window.innerHeight, parent: 'game-container',
    physics: { default: 'arcade', arcade: { gravity: { y: 0 }, debug: false } },
    scene: { preload: preload, create: create, update: update },
    backgroundColor: '#3b7d4f'
};

game = new Phaser.Game(config);

function preload() {
    this.load.image('player', 'https://github.com/darkbearlab/gunFightSurvivor/blob/main/player.png?raw=true');
    const graphics = this.make.graphics({x: 0, y: 0, add: false});
    graphics.fillStyle(0xffffff, 1); graphics.fillRect(0, 0, 4, 4); graphics.generateTexture('pixel', 4, 4);
}

function getRandomEdgePos(scene, margin) {
    let x, y; if (Math.random() > 0.5) { x = Math.random() > 0.5 ? margin : 2000 - margin; y = Phaser.Math.Between(margin, 2000 - margin); } else { y = Math.random() > 0.5 ? margin : 2000 - margin; x = Phaser.Math.Between(margin, 2000 - margin); } return {x, y};
}

function create() {
    this.physics.world.setBounds(0, 0, 2000, 2000);
    this.add.grid(1000, 1000, 2000, 2000, 50, 50, 0x3b7d4f, 0, 0x000000, 0.1);

    obstacles = this.physics.add.staticGroup();
    // [ä¿®æ­£] å°‡æ‰€æœ‰ Group çš„ runChildUpdate è¨­ç‚º falseï¼Œé¿å… Phaser è‡ªå‹•å‘¼å« update(time, delta) å°è‡´åƒæ•¸éŒ¯èª¤
    squad = this.add.group({ runChildUpdate: false });
    enemies = this.add.group({ runChildUpdate: false });
    wildLife = this.add.group({ runChildUpdate: false });
    projectiles = this.add.group({ runChildUpdate: false });

    for (let i = 0; i < 80; i++) {
        let tx = Phaser.Math.Between(50, 1950); let ty = Phaser.Math.Between(50, 1950); let clear = true;
        [[400,400], [1000,1000], [1600,1600]].forEach(p => { if(Math.abs(tx-p[0])<150 && Math.abs(ty-p[1])<150) clear = false; });
        if (clear) { let tree = this.add.rectangle(tx, ty, 40, 40, 0x1e4726); this.physics.add.existing(tree, true); obstacles.add(tree); }
    }

    villages = [ new Village(this, 400, 400, "åŒ—å¢ƒæ‘"), new Village(this, 1000, 1000, "ä¸­å¤®å¸‚é›†"), new Village(this, 1600, 1600, "å—é¢¨é®") ];
    player = new Hero(this, 1000, 1100);
    // [ä¿®æ­£] Zoom æ”¹å› 1.0
    this.cameras.main.startFollow(player, true, 0.09, 0.09); this.cameras.main.setZoom(1.0);
    
    for(let i=0; i<12; i++) { let p=getRandomEdgePos(this, 100); wildLife.add(new Deer(this, p.x, p.y)); }
    for(let i=0; i<5; i++) { let p=getRandomEdgePos(this, 100); wildLife.add(new Wolf(this, p.x, p.y)); }

    // ç‰©ç†ç¢°æ’
    this.physics.add.collider(player, obstacles); this.physics.add.collider(player, enemies); this.physics.add.collider(player, wildLife);
    this.physics.add.collider(squad, obstacles); this.physics.add.collider(enemies, obstacles);
    this.physics.add.collider(wildLife, obstacles);
    this.physics.add.collider(squad, squad);
    this.physics.add.collider(squad, enemies);

    // å‚·å®³åˆ¤å®š
    this.physics.add.overlap(projectiles, enemies, (p, e) => { if(!p.isEnemy) { e.takeDamage(p.damage); p.destroy(); } });
    this.physics.add.overlap(projectiles, wildLife, (p, e) => { if(!p.isEnemy) { e.takeDamage(p.damage); p.destroy(); } });
    this.physics.add.overlap(projectiles, squad, (p, s) => { if(p.isEnemy) { s.takeDamage(p.damage); p.destroy(); } });
    this.physics.add.overlap(projectiles, player, (p, h) => { if(p.isEnemy) { h.takeDamage(p.damage); p.destroy(); } });

    uiTexts.gold = document.getElementById('gold-display');
    uiTexts.squad = document.getElementById('squad-count');
    uiTexts.enemy = document.getElementById('enemy-count');
    uiTexts.mode = document.getElementById('mode-indicator');
    uiTexts.time = document.getElementById('time-display');
    uiTexts.rep = document.getElementById('rep-display');
    uiTexts.repBar = document.getElementById('rep-bar');
    updateGold(0); updateRep(0);

    cursors = this.input.keyboard.createCursorKeys();
    wasd = this.input.keyboard.addKeys({ up: 'W', down: 'S', left: 'A', right: 'D' });
    keys = this.input.keyboard.addKeys({ H: 'H', J: 'J', U: 'U', SPACE: 'SPACE' });
    
    director = new GameDirector(this);
    
    this.time.addEvent({ delay: 1000, callback: () => {
        if (!isGameOver) {
            gameTimeLeft--;
            let m = Math.floor(gameTimeLeft/60); let s = gameTimeLeft%60;
            uiTexts.time.innerText = `${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;
            checkGameOver();
        }
    }, loop: true });
    
    // Fallback: å¦‚æœåœ–ç‰‡è¼‰å…¥å¤±æ•—ï¼Œæœƒé¡¯ç¤ºé è¨­çš„ç¶ è‰²æ–¹å¡Š (Phaser é è¨­è¡Œç‚º)
    // ä½†ç‚ºäº†ä¿éšªï¼Œå¯ä»¥åœ¨é€™è£¡æª¢æŸ¥ texture æ˜¯å¦å­˜åœ¨
    if (!this.textures.exists('player')) {
        console.log("Player texture missing, fallback logic active.");
    }
}

function update(time, delta) {
    if (isGameOver) return;
    
    player.update();
    director.update(delta);
    
    villages.forEach(v => v.update(delta, enemies));
    
    if (Phaser.Input.Keyboard.JustDown(keys.SPACE)) {
        isAutoAttackMode = !isAutoAttackMode;
        uiTexts.mode.innerText = isAutoAttackMode ? "âš”ï¸ è‡ªå‹•æ”»æ“Š" : "ğŸ›¡ï¸ è·Ÿéš¨";
        uiTexts.mode.style.color = isAutoAttackMode ? "red" : "lime";
    }
    
    let activeVillage = null;
    villages.forEach(v => {
        if (Phaser.Math.Distance.Between(player.x, player.y, v.x, v.y) < 60) activeVillage = v;
    });
    
    if (activeVillage) {
        if (Phaser.Input.Keyboard.JustDown(keys.U)) activeVillage.upgrade();
        if (Phaser.Input.Keyboard.JustDown(keys.H)) if(activeVillage.recruit('H')) squad.add(new Soldier(this, player.x, player.y));
        if (Phaser.Input.Keyboard.JustDown(keys.J)) if(activeVillage.recruit('J')) squad.add(new Archer(this, player.x, player.y));
    }
    
    squad.children.iterate(u => u && u.update(player, isAutoAttackMode));
    enemies.children.iterate(u => u && u.update && u.update());
    wildLife.children.iterate(u => u && u.update && u.update());
    projectiles.children.iterate(p => p && p.update());

    uiTexts.squad.innerText = squad.countActive(true);
    uiTexts.enemy.innerText = enemies.countActive(true);
}

window.addEventListener('resize', () => game.scale.resize(window.innerWidth, window.innerHeight));
</script>

</body>
</html>
