<!DOCTYPE html>
<html>
<head>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser-arcade-physics.min.js"></script>
    <style> body { margin: 0; background: #111; touch-action: none; } </style>
</head>
<body>
    <script>
        class MyGame extends Phaser.Scene {
            constructor() {
                super();
                this.score = 0;
                this.lastSpawn = 0;
            }

            preload() {
                this.createTexture('p', 24, 24, 0x00ff00); // 玩家
                this.createTexture('e1', 24, 24, 0xff0000); // 點射敵(紅)
                this.createTexture('e2', 24, 24, 0xff00ff); // 連發敵(紫)
                this.createTexture('e3', 24, 24, 0xffa500); // 霰彈敵(橘)
                this.createTexture('b', 8, 8, 0xffff00);   // 子彈
                this.createTexture('eb', 8, 8, 0xffffff);  // 敵彈
                this.createTexture('cov', 1, 1, 0x666666); // 掩體
            }

            createTexture(key, w, h, color) {
                const g = this.make.graphics({ x: 0, y: 0, add: false });
                g.fillStyle(color, 1); g.fillRect(0, 0, w, h);
                g.generateTexture(key, w, h);
            }

            create() {
                this.physics.world.setBounds(0, 0, 2000, 2000);
                this.cameras.main.setBounds(0, 0, 2000, 2000);

                // 1. 群組初始化
                this.player = this.physics.add.sprite(1000, 1000, 'p').setCollideWorldBounds(true).setDepth(2);
                this.cameras.main.startFollow(this.player, true, 0.1, 0.1);

                this.enemies = this.physics.add.group({ classType: Enemy, runChildUpdate: true });
                this.bullets = this.physics.add.group({ defaultKey: 'b' });
                this.enemyBullets = this.physics.add.group({ defaultKey: 'eb' });
                this.covers = this.physics.add.staticGroup();

                // 2. 生成掩體 (隨機多邊形視覺由拉伸矩形模擬)
                for(let i=0; i<15; i++) {
                    let cx = Phaser.Math.Between(200, 1800), cy = Phaser.Math.Between(200, 1800);
                    if(Phaser.Math.Distance.Between(cx, cy, 1000, 1000) < 200) continue;
                    let c = this.covers.create(cx, cy, 'cov');
                    c.setDisplaySize(Phaser.Math.Between(40, 100), Phaser.Math.Between(40, 100)).refreshBody();
                    c.setData('hp', 3);
                }

                // 3. 碰撞邏輯
                this.physics.add.collider(this.player, this.covers);
                this.physics.add.collider(this.enemies, this.covers);
                this.physics.add.collider(this.enemies, this.enemies); // 敵人間有碰撞

                // TK (友軍傷害) 實作：敵彈碰到敵人
                this.physics.add.overlap(this.enemyBullets, this.enemies, (bullet, enemy) => {
                    bullet.destroy(); enemy.takeDamage(1);
                });
                
                this.physics.add.overlap(this.bullets, this.enemies, (bullet, enemy) => {
                    bullet.destroy(); enemy.takeDamage(1);
                });

                this.physics.add.overlap(this.enemyBullets, this.player, () => this.gameOver());
                this.physics.add.overlap(this.enemyBullets, this.covers, (b, c) => this.hitCover(b, c));
                this.physics.add.overlap(this.bullets, this.covers, (b, c) => this.hitCover(b, c));
                this.physics.add.overlap(this.enemies, this.player, () => this.gameOver());

                // 4. 虛擬搖桿與輸入 (支援 2 個多點觸控)
                this.input.addPointer(1); 
                this.joyL = { x: 120, y: 480, radius: 60, active: false, pointer: null };
                this.joyR = { x: 680, y: 480, radius: 60, active: false, pointer: null, angle: 0 };
                
                this.uiGraphics = this.add.graphics().setScrollFactor(0).setDepth(10);
                this.laserGraphics = this.add.graphics().setDepth(1);

                this.time.addEvent({ delay: 2000, callback: this.spawnEnemy, callbackScope: this, loop: true });
            }

            hitCover(bullet, cover) {
                bullet.destroy();
                let hp = cover.getData('hp') - 1;
                cover.setData('hp', hp);
                cover.setAlpha(hp / 3);
                if (hp <= 0) cover.destroy();
            }

            gameOver() {
                alert("你死了！分數: " + this.score);
                location.reload();
            }

            update() {
                this.handleInputs();
                this.drawUI();
            }

            handleInputs() {
                this.player.setVelocity(0);
                let moveSpeed = 200;

                // 處理左搖桿 (移動)
                [this.input.pointer1, this.input.pointer2, this.input.mousePointer].forEach(p => {
                    if (p.isDown) {
                        let dL = Phaser.Math.Distance.Between(p.x, p.y, this.joyL.x, this.joyL.y);
                        let dR = Phaser.Math.Distance.Between(p.x, p.y, this.joyR.x, this.joyR.y);

                        if (dL < 100 && !this.joyR.pointer === p) {
                            this.joyL.active = true;
                            this.joyL.pointer = p;
                        } else if (dR < 100 && !this.joyL.pointer === p) {
                            this.joyR.active = true;
                            this.joyR.pointer = p;
                        }
                    }
                });

                if (this.joyL.pointer && !this.joyL.pointer.isDown) { this.joyL.active = false; this.joyL.pointer = null; }
                if (this.joyR.pointer && !this.joyR.pointer.isDown) { 
                    if (this.joyR.active) this.firePlayerBullet();
                    this.joyR.active = false; this.joyR.pointer = null; 
                }

                // 執行移動
                if (this.joyL.active) {
                    let angle = Phaser.Math.Angle.Between(this.joyL.x, this.joyL.y, this.joyL.pointer.x, this.joyL.pointer.y);
                    if (this.joyR.active) moveSpeed *= 0.5; // 瞄準時減速
                    this.player.setVelocity(Math.cos(angle) * moveSpeed, Math.sin(angle) * moveSpeed);
                }

                // 處理右搖桿 (瞄準)
                this.laserGraphics.clear();
                if (this.joyR.active) {
                    this.joyR.angle = Phaser.Math.Angle.Between(this.joyR.x, this.joyR.y, this.joyR.pointer.x, this.joyR.pointer.y);
                    this.player.rotation = this.joyR.angle;
                    
                    // 畫雷射線
                    this.laserGraphics.lineStyle(1, 0x00ff00, 0.5);
                    let lx = this.player.x + Math.cos(this.joyR.angle) * 1000;
                    let ly = this.player.y + Math.sin(this.joyR.angle) * 1000;
                    this.laserGraphics.lineBetween(this.player.x, this.player.y, lx, ly);
                }
            }

            firePlayerBullet() {
                let b = this.bullets.get(this.player.x, this.player.y);
                if (b) {
                    b.setActive(true).setVisible(true);
                    this.physics.velocityFromRotation(this.joyR.angle, 600, b.body.velocity);
                }
            }

            spawnEnemy() {
                let angle = Math.random() * Math.PI * 2;
                let x = this.player.x + Math.cos(angle) * 600;
                let y = this.player.y + Math.sin(angle) * 600;
                let type = Phaser.Math.Between(1, 3);
                this.enemies.get(x, y, 'e' + type).init(type);
            }

            drawUI() {
                this.uiGraphics.clear();
                this.uiGraphics.lineStyle(2, 0xffffff, 0.5);
                this.uiGraphics.strokeCircle(this.joyL.x, this.joyL.y, this.joyL.radius);
                this.uiGraphics.strokeCircle(this.joyR.x, this.joyR.y, this.joyR.radius);
                if (this.joyL.active) this.uiGraphics.fillStyle(0x00ff00, 0.5).fillCircle(this.joyL.pointer.x, this.joyL.pointer.y, 20);
                if (this.joyR.active) this.uiGraphics.fillStyle(0xff0000, 0.5).fillCircle(this.joyR.pointer.x, this.joyR.pointer.y, 20);
            }
        }

        class Enemy extends Phaser.Physics.Arcade.Sprite {
            init(type) {
                this.type = type; // 1:點射, 2:連發, 3:霰彈
                this.hp = 2;
                this.lastFire = 0;
                this.setTint(type === 1 ? 0xff0000 : (type === 2 ? 0xff00ff : 0xffa500));
            }
            takeDamage(n) {
                this.hp -= n; if(this.hp <= 0) { this.scene.score += 10; this.destroy(); }
            }
            update(time) {
                if(!this.body) return;
                let dist = Phaser.Math.Distance.Between(this.x, this.y, this.scene.player.x, this.scene.player.y);
                
                // AI: 保持距離
                if(dist > 300) this.scene.physics.moveToObject(this, this.scene.player, 80);
                else if(dist < 200) this.scene.physics.moveToObject(this, this.scene.player, -60);
                else this.setVelocity(0);

                // 射擊邏輯
                if (time > this.lastFire + (this.type === 2 ? 400 : 1500)) {
                    this.fire(); this.lastFire = time;
                }
            }
            fire() {
                let angle = Phaser.Math.Angle.Between(this.x, this.y, this.scene.player.x, this.scene.player.y);
                const shoot = (a) => {
                    let b = this.scene.enemyBullets.get(this.x, this.y);
                    if(b) { b.setActive(true).setVisible(true); this.scene.physics.velocityFromRotation(a, 300, b.body.velocity); }
                };

                if (this.type === 1) shoot(angle);
                else if (this.type === 2) { 
                    for(let i=0; i<3; i++) this.scene.time.delayedCall(i*100, () => shoot(angle)); 
                }
                else if (this.type === 3) {
                    for(let i=-1; i<=1; i++) shoot(angle + i*0.3);
                }
            }
        }

        new Phaser.Game({
            type: Phaser.AUTO, width: 800, height: 600,
            physics: { default: 'arcade' },
            scene: MyGame,
            input: { activePointers: 3 }
        });
    </script>
</body>
</html>
