<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ÁæÖË≥ìÊº¢Êà∞Ë®ò - Phase 14</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
    <style>
        body { 
            margin: 0; padding: 0; background-color: #2d2d2d; overflow: hidden; 
            font-family: 'Segoe UI', sans-serif; 
            user-select: none; -webkit-user-select: none; 
            touch-action: none; color: white;
        }
        #game-container { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; }
        
        /* HUD */
        #ui-layer {
            position: absolute; top: 10px; left: 10px; right: 10px; pointer-events: none;
            text-shadow: 1px 1px 2px black; display: flex; flex-direction: column; gap: 5px; z-index: 10;
        }
        .hud-box { background-color: rgba(0, 0, 0, 0.6); padding: 10px; border-radius: 8px; pointer-events: auto; }
        .stat-row { display: flex; justify-content: space-between; margin-bottom: 2px; font-size: 14px; }
        .bar-container { width: 100%; background: #444; height: 8px; border-radius: 4px; margin-top: 2px; overflow: hidden; }
        .bar-fill { height: 100%; background: lime; width: 0%; transition: width 0.5s; }
        .buff-icon { display: none; margin-right: 5px; color: gold; font-weight: bold; }

        /* Mobile Controls */
        #mobile-controls { position: absolute; bottom: 20px; right: 20px; z-index: 15; pointer-events: auto; }
        #mode-btn {
            width: 80px; height: 80px; border-radius: 50%; border: 4px solid white;
            background-color: rgba(0, 255, 0, 0.5); color: white; font-weight: bold; font-size: 14px;
            display: flex; justify-content: center; align-items: center; text-align: center;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5); cursor: pointer; transition: transform 0.1s;
        }
        #mode-btn:active { transform: scale(0.95); }

        /* Start Screen */
        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); z-index: 50;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        h1 { margin-bottom: 30px; color: gold; text-shadow: 0 0 10px orange; font-size: 40px; }
        .skill-container { display: flex; gap: 20px; margin-bottom: 40px; }
        .skill-card {
            width: 110px; height: 140px; border: 2px solid #555; border-radius: 10px;
            background: #222; display: flex; flex-direction: column; align-items: center; justify-content: center;
            cursor: pointer; transition: all 0.2s; position: relative; padding: 10px; text-align: center;
        }
        .skill-card.selected { border-color: lime; background: #004400; box-shadow: 0 0 15px lime; }
        .skill-icon { font-size: 40px; margin-bottom: 10px; }
        .skill-name { font-size: 16px; font-weight: bold; margin-bottom: 5px; color: white;}
        .skill-desc { font-size: 12px; color: #aaa; }
        #start-btn {
            padding: 15px 50px; font-size: 24px; background: gold; color: black; border: none;
            border-radius: 8px; cursor: pointer; font-weight: bold; box-shadow: 0 5px 15px rgba(255,215,0,0.4);
        }
        #start-btn:active { transform: translateY(2px); }
        
        #gear-btn {
            position: absolute; top: 20px; right: 20px; font-size: 30px; cursor: pointer; color: #888; transition: color 0.3s;
        }
        #gear-btn:hover { color: white; transform: rotate(90deg); }

        /* Settings Modal */
        #settings-modal {
            display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 80%; max-width: 500px; max-height: 80vh; background: #222; border: 2px solid #555;
            border-radius: 10px; padding: 20px; z-index: 60; overflow-y: auto; box-shadow: 0 0 30px black;
        }
        .settings-group { margin-bottom: 15px; border-bottom: 1px solid #444; padding-bottom: 10px; }
        .settings-group h3 { color: cyan; margin: 0 0 10px 0; font-size: 16px; }
        .input-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
        .input-row label { font-size: 14px; color: #ccc; }
        .input-row input { width: 80px; padding: 5px; background: #111; border: 1px solid #444; color: white; text-align: right; border-radius: 4px; }
        .modal-btns { display: flex; justify-content: flex-end; gap: 10px; margin-top: 20px; }
        .modal-btn { padding: 8px 20px; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; }
        .save-btn { background: lime; color: black; }
        .cancel-btn { background: #555; color: white; }

        /* Game Over Screen */
        #game-over-screen {
            display: none; position: absolute; top: 0; left: 0; width: 100vw; height: 100vh;
            background: rgba(0,0,0,0.85); color: white; z-index: 20;
            flex-direction: column; justify-content: center; align-items: center; text-align: center;
        }
        #game-over-title { font-size: 3em; margin-bottom: 20px; font-weight: bold; }
        button.restart-btn { margin-top: 30px; padding: 15px 40px; font-size: 1.5em; cursor: pointer; background: gold; border: none; border-radius: 8px; font-weight: bold; }
    </style>
</head>
<body>

<!-- UI Layer -->
<div id="ui-layer" style="display:none;">
    <div class="hud-box">
        <div class="stat-row">
            <span>‚è≥ <span id="time-display" style="color: cyan;">05:00</span></span>
            <span>üí∞ <span id="gold-display" style="color: gold;">0</span></span>
        </div>
        <div>
            ÂêçËÅ≤: <span id="rep-display">0</span> / <span id="target-rep-display">3000</span>
            <div class="bar-container"><div id="rep-bar" class="bar-fill"></div></div>
        </div>
        <div style="margin-top:5px; font-size:12px; color:#aaa; display: flex; align-items: center;">
            <span style="margin-right: 10px;">ÈÉ®Èöä: <span id="squad-count">0</span> | ÊïµËªç: <span id="enemy-count">0</span></span>
            <span id="buff-gold" class="buff-icon">üèÜ</span>
            <span id="buff-rep" class="buff-icon">üìú</span>
        </div>
    </div>
</div>

<div id="mobile-controls" style="display:none;">
    <div id="mode-btn" onclick="toggleMode()">üõ°Ô∏è<br>Ë∑üÈö®</div>
</div>

<!-- Start Screen (Class Selection) -->
<div id="start-screen">
    <div id="gear-btn" onclick="openSettings()">‚öôÔ∏è</div>
    <h1>ÁæÖË≥ìÊº¢Êà∞Ë®ò</h1>
    <div class="skill-container">
        <div class="skill-card selected" onclick="selectClass(this, 'warrior')">
            <div class="skill-icon">‚öîÔ∏è</div>
            <div class="skill-name">Êà∞Â£´</div>
            <div class="skill-desc">È´òË°ÄÈáè<br>ËøëÊà∞ÈÄüÊîª</div>
        </div>
        <div class="skill-card" onclick="selectClass(this, 'archer')">
            <div class="skill-icon">üèπ</div>
            <div class="skill-name">Â∞ÑÊâã</div>
            <div class="skill-desc">‰ΩéË°ÄÈáè<br>Èï∑Á®ãÁãôÊìä</div>
        </div>
        <div class="skill-card" onclick="selectClass(this, 'mage')">
            <div class="skill-icon">üîÆ</div>
            <div class="skill-name">Ê≥ïÂ∏´</div>
            <div class="skill-desc">Ê•µËÑÜÁöÆ<br>ÁØÑÂúçÂõûË°Ä</div>
        </div>
    </div>
    <button id="start-btn" onclick="startGame()">ÈñãÂßãËµ∑Áæ©</button>
</div>

<!-- Settings Modal -->
<div id="settings-modal">
    <h2 style="margin-top:0; border-bottom:1px solid #555; padding-bottom:10px;">ÈÅäÊà≤Âπ≥Ë°°Ë®≠ÂÆö</h2>
    <div id="settings-content"></div>
    <div class="modal-btns">
        <button class="modal-btn cancel-btn" onclick="closeSettings()">ÂèñÊ∂à</button>
        <button class="modal-btn save-btn" onclick="saveSettings()">‰øùÂ≠ò‰∏¶ÈóúÈñâ</button>
    </div>
</div>

<!-- Game Over -->
<div id="game-over-screen">
    <div id="game-over-title">GAME OVER</div>
    <div id="game-over-desc" style="padding: 0 20px;"></div>
    <button class="restart-btn" onclick="location.reload()">ÂÜçÁé©‰∏ÄÊ¨°</button>
</div>

<div id="game-container"></div>

<script>
// --- Config ---
const G = {
    gameDuration: 300, targetRep: 3000, initialGold: 300,
    heroSpeed: 220, // ÈÄôÊòØÂü∫Á§éÈÄüÂ∫¶ÔºåËÅ∑Ê•≠ÊúÉ‰øÆÊ≠£ÂÆÉ
    costSoldier: 20, costArcher: 30, upgradeCostFactor: 100, dropRate: 0.2,
    patrolBaseInterval: 40000,
    selectedClass: 'warrior' // warrior, archer, mage
};

let game, player, director;
let gold = 0; let reputation = 0; let isAutoAttackMode = false;
let gameTimeLeft = 0; let isGameOver = false; let isGameStarted = false;
let permanentBuffs = { gold: false, rep: false };
let joyStick = { active: false, startX: 0, startY: 0, currX: 0, currY: 0, vec: new Phaser.Math.Vector2(0,0) };
let squad, enemies, wildLife, obstacles, projectiles, loots, neutrals;
let villages = []; let manors = []; let uiTexts = {}; 
let cursors, wasd, keys, joyGraphics;

// --- UI Logic ---
function selectClass(el, cls) {
    document.querySelectorAll('.skill-card').forEach(c => c.classList.remove('selected'));
    el.classList.add('selected');
    G.selectedClass = cls;
}

function startGame() {
    document.getElementById('start-screen').style.display = 'none';
    document.getElementById('ui-layer').style.display = 'flex';
    document.getElementById('mobile-controls').style.display = 'block';
    
    gold = G.initialGold;
    gameTimeLeft = G.gameDuration;
    document.getElementById('target-rep-display').innerText = G.targetRep;
    
    updateGold(0);
    isGameStarted = true;
    
    // ÂàùÂßãÂåñÁé©ÂÆ∂ÊôÇÊúÉËÆÄÂèñ G.selectedClass
    if (player) player.initClassStats();
}

function openSettings() {
    const content = document.getElementById('settings-content');
    content.innerHTML = '';
    const settingsMap = [
        { title: "ÂÆèËßÄË¶èÂâá", items: [{ key: 'gameDuration', label: 'ÊôÇÈñì(Áßí)' }, { key: 'targetRep', label: 'ÁõÆÊ®ôÂêçËÅ≤' }, { key: 'initialGold', label: 'ÂàùÂßãÈáë' }] },
        { title: "Á∂ìÊøüÂπ≥Ë°°", items: [{ key: 'costSoldier', label: 'Ê≠•ÂÖµÂÉπ' }, { key: 'costArcher', label: 'ÂºìÂÖµÂÉπ' }, { key: 'dropRate', label: 'ÊéâÂØ∂Áéá' }] },
        { title: "Èõ£Â∫¶", items: [{ key: 'patrolBaseInterval', label: 'Â∑°ÈÇèÈñìÈöî' }] }
    ];
    settingsMap.forEach(group => {
        let html = `<div class="settings-group"><h3>${group.title}</h3>`;
        group.items.forEach(item => { html += `<div class="input-row"><label>${item.label}</label><input type="number" id="cfg-${item.key}" value="${G[item.key]}" step="${item.key==='dropRate'?0.1:10}"></div>`; });
        html += `</div>`; content.innerHTML += html;
    });
    document.getElementById('settings-modal').style.display = 'block';
}
function closeSettings() { document.getElementById('settings-modal').style.display = 'none'; }
function saveSettings() {
    for (let key in G) { let input = document.getElementById(`cfg-${key}`); if (input) G[key] = parseFloat(input.value); }
    closeSettings();
}

function toggleMode() {
    isAutoAttackMode = !isAutoAttackMode;
    const btn = document.getElementById('mode-btn');
    if (isAutoAttackMode) { btn.innerHTML = "‚öîÔ∏è<br>ÊîªÊìä"; btn.style.backgroundColor = "rgba(255, 0, 0, 0.6)"; } 
    else { btn.innerHTML = "üõ°Ô∏è<br>Ë∑üÈö®"; btn.style.backgroundColor = "rgba(0, 255, 0, 0.5)"; }
}

function updateGold(amount) { gold += amount; if(uiTexts.gold) uiTexts.gold.innerText = Math.floor(gold); }
function updateRep(amount) { reputation += amount; if(reputation<0)reputation=0; if(uiTexts.rep) { uiTexts.rep.innerText = Math.floor(reputation); let pct = Math.min((reputation/G.targetRep)*100,100); uiTexts.repBar.style.width = pct+"%"; } }
function showDamageText(scene, x, y, amount, color='#fff') { let text = scene.add.text(x, y-20, amount, { fontSize: '16px', color: color, stroke: '#000', strokeThickness: 3, fontWeight: 'bold' }).setOrigin(0.5).setDepth(20); scene.tweens.add({ targets: text, y: y-50, alpha: 0, duration: 800, onComplete: () => text.destroy() }); }
function showToast(scene, msg, color) { let text = scene.add.text(player.x, player.y-150, msg, { fontSize: '20px', color: color, stroke: '#000', strokeThickness: 4, backgroundColor: 'rgba(0,0,0,0.6)', padding: {x:10, y:5} }).setOrigin(0.5).setDepth(100); scene.tweens.add({ targets: text, y: player.y-200, alpha: 0, duration: 3000, onComplete: () => text.destroy() }); }
function checkGameOver() { if(isGameOver)return; if(gameTimeLeft<=0) { if(reputation>=G.targetRep) endGame(true, "ÂÇ≥Â•áË™ïÁîüÔºÅ<br>‰Ω†ÊàêÂäüÊäµÊäó‰∫ÜÊö¥Êîø„ÄÇ"); else endGame(false, "Ëµ∑Áæ©Â§±Êïó„ÄÇ<br>Ê≠∑Âè≤ÈÅ∫Âøò‰∫Ü‰Ω†ÁöÑÂêçÂ≠ó„ÄÇ"); } }
function endGame(victory, message) { isGameOver=true; game.scene.pause("default"); document.getElementById('game-over-screen').style.display='flex'; document.getElementById('game-over-title').innerText = victory?"VICTORY!":"DEFEAT"; document.getElementById('game-over-title').style.color=victory?"gold":"red"; document.getElementById('game-over-desc').innerHTML = message; }

// --- Classes ---

class Loot extends Phaser.GameObjects.Text {
    constructor(scene, x, y, type) {
        let icon = 'üí∞'; if (type === 'heal') icon = '‚ù§Ô∏è'; else if (type === 'buff') icon = '‚öîÔ∏è';
        super(scene, x, y, icon, { fontSize: '20px' }); scene.add.existing(this); scene.physics.add.existing(this); this.type = type; this.bornTime = Date.now(); scene.tweens.add({ targets: this, y: y-5, duration: 500, yoyo: true, repeat: -1 });
    }
    pickup() {
        if (this.type === 'heal') { player.heal(50); } 
        else if (this.type === 'gold') { updateGold(50); updateRep(10); showDamageText(this.scene, player.x, player.y, "+$50", "gold"); } 
        else if (this.type === 'buff') { player.activateBuff(); showToast(this.scene, "ÊîªÊìäÂäõÊèêÂçá!", "red"); }
        this.destroy();
    }
}

class Unit extends Phaser.GameObjects.Rectangle {
    constructor(scene, x, y, width, height, color, hp, maxHp) {
        super(scene, x, y, width, height, color); scene.add.existing(this); scene.physics.add.existing(this);
        const radius = width / 2; this.body.setCircle(radius); this.body.setCollideWorldBounds(true); this.body.setBounce(0); this.body.setDrag(100); this.body.setMass(1);
        this.hp = hp; this.maxHp = maxHp || hp; this.isDead = false; this.lastAttackTime = 0;
        this.hpBarBg = scene.add.rectangle(x, y - height, width, 4, 0x000000).setDepth(1);
        this.hpBar = scene.add.rectangle(x, y - height, width, 4, 0x00ff00).setDepth(1);
    }
    preUpdate() { if (this.isDead) return; this.hpBarBg.setPosition(this.x, this.y - this.height/2 - 5); this.hpBar.setPosition(this.x, this.y - this.height/2 - 5); }
    takeDamage(amount) { if (this.isDead) return; this.hp -= amount; showDamageText(this.scene, this.x, this.y, amount); this.updateHpBar(); if (this.hp <= 0) this.die(); }
    
    // [Êñ∞Â¢û] Ê≤ªÁôÇÊñπÊ≥ï
    heal(amount) {
        if (this.isDead || this.hp >= this.maxHp) return;
        this.hp = Math.min(this.hp + amount, this.maxHp);
        showDamageText(this.scene, this.x, this.y, `+${amount}`, "#00ff00");
        this.updateHpBar();
    }
    
    updateHpBar() {
        const pct = Math.max(0, this.hp / this.maxHp); this.hpBar.width = this.width * pct;
        if (pct < 0.3) this.hpBar.fillColor = 0xff0000; else if (pct < 0.6) this.hpBar.fillColor = 0xffff00; else this.hpBar.fillColor = 0x00ff00;
    }

    die() {
        this.isDead = true; this.hpBar.destroy(); this.hpBarBg.destroy();
        if (Math.random() < G.dropRate) { let r = Math.random(); let type = 'gold'; if (r < 0.4) type = 'heal'; else if (r < 0.5) type = 'buff'; loots.add(new Loot(this.scene, this.x, this.y, type)); }
        const particles = this.scene.add.particles(this.x, this.y, 'pixel', { speed: 100, scale: { start: 1, end: 0 }, lifespan: 500, blendMode: 'ADD', tint: this.fillColor });
        this.scene.time.delayedCall(500, () => particles.destroy());
        this.destroy();
    }
}

class Projectile extends Phaser.GameObjects.Rectangle {
    constructor(scene, x, y, target, damage, isEnemy, speed, lifeTime, color) {
        super(scene, x, y, 10, 4, color || (isEnemy ? 0xff4444 : 0xffff00)); scene.add.existing(this); scene.physics.add.existing(this);
        this.damage = damage; this.isEnemy = isEnemy; this.bornTime = Date.now(); this.lifeTime = lifeTime || 1000;
        const angle = Phaser.Math.Angle.Between(x, y, target.x, target.y); this.rotation = angle;
        scene.physics.velocityFromRotation(angle, speed || 400, this.body.velocity);
    }
    update() { if (Date.now() - this.bornTime > this.lifeTime) this.destroy(); }
}
class MeleeSlash extends Projectile {
    constructor(scene, x, y, target, damage, isEnemy) { super(scene, x, y, target, damage, isEnemy, 600, 150, 0xffffff); this.width = 16; this.height = 16; scene.tweens.add({ targets: this, scaleX: 1.5, scaleY: 1.5, alpha: 0, duration: 150 }); }
}

// --- Ëã±ÈõÑ (ËÅ∑Ê•≠Á≥ªÁµ±Ê†∏ÂøÉ) ---
class Hero extends Phaser.Physics.Arcade.Sprite {
    constructor(scene, x, y) {
        super(scene, x, y, 'player', 0);
        scene.add.existing(this); scene.physics.add.existing(this); this.setScale(1.0);
        this.body.setCircle(12, 4, 8); this.body.setCollideWorldBounds(true); this.body.setMass(100); 
        this.hp = 300; this.maxHp = 300; this.isDead = false; this.lastAttackTime = 0;
        this.speed = G.heroSpeed; this.detectRange = 100; this.attackCooldown = 500;
        this.damageMultiplier = 1; this.buffTimer = 0;
        this.classType = 'warrior'; 
        this.healTimer = 0; // Ê≥ïÂ∏´Áî®

        this.hpBarBg = scene.add.rectangle(x, y - 30, 40, 4, 0x000000).setDepth(1);
        this.hpBar = scene.add.rectangle(x, y - 30, 40, 4, 0x00ff00).setDepth(1);
        this.play('walk-down', true); this.anims.stop();
    }
    
    // [Êñ∞Â¢û] ÂàùÂßãÂåñËÅ∑Ê•≠Êï∏ÂÄº
    initClassStats() {
        this.classType = G.selectedClass;
        if (this.classType === 'warrior') {
            this.maxHp = 450;
            this.hp = 450;
            this.attackCooldown = 300; // ÊîªÈÄüÂø´
            this.detectRange = 80;     // Ë∑ùÈõ¢Áü≠
            this.speed = G.heroSpeed;
        } else if (this.classType === 'archer') {
            this.maxHp = 200;
            this.hp = 200;
            this.attackCooldown = 600; // ÊîªÈÄüÊÖ¢
            this.detectRange = 300;    // Ë∑ùÈõ¢Èï∑
            this.speed = G.heroSpeed * 1.1; // Ë∑ëÂø´‰∏ÄÈªûÈªû
        } else if (this.classType === 'mage') {
            this.maxHp = 150;
            this.hp = 150;
            this.attackCooldown = 500;
            this.detectRange = 180;    // ‰∏≠Ë∑ùÈõ¢
            this.speed = G.heroSpeed;
        }
    }

    preUpdate(time, delta) {
        super.preUpdate(time, delta); if (this.isDead) return;
        this.hpBarBg.setPosition(this.x, this.y - 30); this.hpBar.setPosition(this.x, this.y - 30);
        if (this.buffTimer > 0) { this.buffTimer -= delta; if (this.buffTimer <= 0) { this.damageMultiplier = 1; this.clearTint(); } }
        
        // [Êñ∞Â¢û] Ê≥ïÂ∏´Ë¢´ÂãïÊ≤ªÁôÇ
        if (this.classType === 'mage') {
            this.healTimer += delta;
            if (this.healTimer > 2000) { // ÊØè2Áßí
                this.performHealAura();
                this.healTimer = 0;
            }
        }
    }
    
    performHealAura() {
        // Ë¶ñË¶∫ÁâπÊïà
        const aura = this.scene.add.circle(this.x, this.y, 150, 0x00ff00, 0.2);
        this.scene.tweens.add({ targets: aura, alpha: 0, scale: 1.2, duration: 500, onComplete: () => aura.destroy() });
        
        // Ê≤ªÁôÇËá™Â∑±
        this.heal(10);
        // Ê≤ªÁôÇÁØÑÂúçÂÖßÁöÑÂ£´ÂÖµ
        squad.children.iterate(s => {
            if (s && !s.isDead && Phaser.Math.Distance.Between(this.x, this.y, s.x, s.y) < 150) {
                s.heal(10);
            }
        });
    }

    activateBuff() { this.buffTimer = 10000; this.damageMultiplier = 2; this.setTint(0xff0000); }
    move() {
        this.body.setVelocity(0); let vx = 0, vy = 0;
        if (cursors.left.isDown || wasd.left.isDown) vx = -1; else if (cursors.right.isDown || wasd.right.isDown) vx = 1;
        if (cursors.up.isDown || wasd.up.isDown) vy = -1; else if (cursors.down.isDown || wasd.down.isDown) vy = 1;
        if (joyStick.active) { vx = joyStick.vec.x; vy = joyStick.vec.y; }
        if (vx !== 0 || vy !== 0) {
            let v = new Phaser.Math.Vector2(vx, vy).normalize().scale(this.speed); this.body.setVelocity(v.x, v.y);
            if (Math.abs(vy) >= Math.abs(vx)) { if (vy > 0) this.play('walk-down', true); else this.play('walk-up', true); } else { if (vx > 0) this.play('walk-right', true); else this.play('walk-left', true); }
        } else { this.anims.stop(); }
    }
    update() {
        if(this.isDead) return; this.move();
        if (Date.now() - this.lastAttackTime > this.attackCooldown) {
            let target = this.findTarget(enemies, this.detectRange); 
            if (!target) target = this.findTarget(wildLife, this.detectRange);
            if (!target) target = this.findTarget(neutrals, this.detectRange);
            if (target) { 
                let dmg = 25 * this.damageMultiplier; 
                // [‰øÆÊîπ] Ê†πÊìöËÅ∑Ê•≠ÁôºÂ∞Ñ‰∏çÂêåÊîªÊìä
                if (this.classType === 'warrior') {
                    projectiles.add(new MeleeSlash(this.scene, this.x, this.y, target, dmg, false)); 
                } else if (this.classType === 'archer') {
                    projectiles.add(new Projectile(this.scene, this.x, this.y, target, dmg, false, 500, 1000, 0xffff00));
                } else if (this.classType === 'mage') {
                    projectiles.add(new Projectile(this.scene, this.x, this.y, target, dmg * 1.2, false, 350, 1000, 0x00ffff)); // Ê≥ïÂ∏´ÁêÉÈ£õÊÖ¢Èªû‰ΩÜÁóõ
                }
                this.lastAttackTime = Date.now(); 
            }
        }
    }
    findTarget(group, range) { let target = null; let minDist = range; group.children.iterate(u => { if (u && !u.isDead && u.body) { let d = Phaser.Math.Distance.Between(this.x, this.y, u.x, u.y); if (d < minDist) { minDist = d; target = u; } } }); return target; }
    heal(amount) { if (this.isDead || this.hp >= this.maxHp) return; this.hp = Math.min(this.hp + amount, this.maxHp); showDamageText(this.scene, this.x, this.y, `+${amount}`, "#00ff00"); this.updateHpBar(); }
    takeDamage(amount) { if (this.isDead) return; this.hp -= amount; showDamageText(this.scene, this.x, this.y, amount); this.updateHpBar(); if (this.hp <= 0) this.die(); }
    updateHpBar() { const pct = Math.max(0, this.hp / this.maxHp); this.hpBar.width = 40 * pct; if (pct < 0.3) this.hpBar.fillColor = 0xff0000; else if (pct < 0.6) this.hpBar.fillColor = 0xffff00; else this.hpBar.fillColor = 0x00ff00; }
    die() { this.isDead = true; this.hpBar.destroy(); this.hpBarBg.destroy(); this.destroy(); endGame(false, "‰Ω†Êà∞Ê≠ªÊ≤ôÂ†¥ÔºåÈù©ÂëΩ‰πãÁÅ´ÁÜÑÊªÖ‰∫Ü„ÄÇ"); }
}

class Soldier extends Unit {
    constructor(scene, x, y) { super(scene, x, y, 20, 20, 0x33ccff, 60, 60); this.speed = 180; this.detectRange = 300; this.guardRange = 120; this.attackRange = 40; this.wanderOffset = new Phaser.Math.Vector2(Phaser.Math.Between(-50,50), Phaser.Math.Between(-50,50)); }
    update(player, isAutoMode) {
        if(this.isDead) return; this.preUpdate();
        if (!isAutoMode) { this.follow(player, false); return; }
        let target = this.findTarget(enemies, this.detectRange); 
        if (!target) target = this.findTarget(neutrals, this.detectRange);
        if (!target && isAutoMode) target = this.findTarget(wildLife, this.detectRange);
        if (target) { let dist = Phaser.Math.Distance.Between(this.x, this.y, target.x, target.y); if (dist <= this.attackRange) { this.body.setVelocity(0); if (Date.now() - this.lastAttackTime > 800) { projectiles.add(new MeleeSlash(this.scene, this.x, this.y, target, 15 * (player.damageMultiplier || 1), false)); this.lastAttackTime = Date.now(); } } else { this.scene.physics.moveToObject(this, target, this.speed * 1.2); } } else { this.follow(player, isAutoMode); }
    }
    findTarget(group, range) { let target = null; let minDist = range; group.children.iterate(u => { if (u && !u.isDead && u.body) { let d = Phaser.Math.Distance.Between(this.x, this.y, u.x, u.y); if (d < minDist) { minDist = d; target = u; } } }); return target; }
    follow(player, isAutoMode) { let d = Phaser.Math.Distance.Between(this.x, this.y, player.x, player.y); if (d > 60) this.scene.physics.moveTo(this, player.x + this.wanderOffset.x, player.y + this.wanderOffset.y, this.speed); else this.body.setVelocity(0); }
}
class Archer extends Unit {
    constructor(scene, x, y) { super(scene, x, y, 16, 16, 0x00ffff, 30, 30); this.speed = 160; this.detectRange = 350; this.attackRange = 180; this.wanderOffset = new Phaser.Math.Vector2(Phaser.Math.Between(-50,50), Phaser.Math.Between(-50,50)); }
    update(player, isAutoMode) {
        if(this.isDead) return; this.preUpdate();
        if (!isAutoMode) { this.follow(player, false); return; }
        let target = this.findTarget(enemies, this.detectRange); 
        if (!target) target = this.findTarget(neutrals, this.detectRange);
        if (!target && isAutoMode) target = this.findTarget(wildLife, this.detectRange);
        if (target) { let d = Phaser.Math.Distance.Between(this.x, this.y, target.x, target.y); if (d > this.attackRange) { this.scene.physics.moveToObject(this, target, this.speed); } else { this.body.setVelocity(0); if (Date.now() - this.lastAttackTime > 1200) { projectiles.add(new Projectile(this.scene, this.x, this.y, target, 15 * (player.damageMultiplier || 1), false)); this.lastAttackTime = Date.now(); } } } else { this.follow(player, isAutoMode); }
    }
    findTarget(group, range) { let target = null; let minDist = range; group.children.iterate(u => { if (u && !u.isDead && u.body) { let d = Phaser.Math.Distance.Between(this.x, this.y, u.x, u.y); if (d < minDist) { minDist = d; target = u; } } }); return target; }
    follow(player, isAutoMode) { let d = Phaser.Math.Distance.Between(this.x, this.y, player.x, player.y); if (d > 70) this.scene.physics.moveTo(this, player.x + this.wanderOffset.x, player.y + this.wanderOffset.y, this.speed); else this.body.setVelocity(0); }
}

class EnemyUnit extends Unit {
    constructor(scene, x, y, color, hp, speed, target) { super(scene, x, y, 20, 20, color, hp, hp); this.moveTarget = target; this.speed = speed; this.attackRange = 40; }
    findAggroTarget() { let target = null; let minDist = 200; let d = Phaser.Math.Distance.Between(this.x, this.y, player.x, player.y); if (d < minDist) { minDist = d; target = player; } squad.children.iterate(s => { if(s && !s.isDead) { let sd = Phaser.Math.Distance.Between(this.x, this.y, s.x, s.y); if (sd < minDist) { minDist = sd; target = s; } } }); return target; }
}
class EnemySoldier extends EnemyUnit {
    constructor(scene, x, y, target, tetherUnit) { super(scene, x, y, 0xff4444, 60, 130, target); this.tetherUnit = tetherUnit; }
    update() {
        if(this.isDead) return; this.preUpdate();
        if (this.tetherUnit && !this.tetherUnit.isDead) { let distToMaster = Phaser.Math.Distance.Between(this.x, this.y, this.tetherUnit.x, this.tetherUnit.y); if (distToMaster > 300) { this.scene.physics.moveToObject(this, this.tetherUnit, this.speed * 1.3); return; } }
        let combatTarget = this.findAggroTarget(); let finalTarget = combatTarget || this.moveTarget;
        if (this.moveTarget instanceof Village) { let distToVillage = Phaser.Math.Distance.Between(this.x, this.y, this.moveTarget.x, this.moveTarget.y); if (distToVillage < this.moveTarget.siegeRadius) { if (!combatTarget) { this.body.setVelocity(0); return; } } }
        if (finalTarget && !finalTarget.isDead) { let dist = Phaser.Math.Distance.Between(this.x, this.y, finalTarget.x, finalTarget.y); if (dist <= this.attackRange) { this.body.setVelocity(0); if (Date.now() - this.lastAttackTime > 1000) { projectiles.add(new MeleeSlash(this.scene, this.x, this.y, finalTarget, 10, true)); this.lastAttackTime = Date.now(); } } else this.scene.physics.moveToObject(this, finalTarget, this.speed); }
    }
}
class EnemyArcher extends EnemyUnit {
    constructor(scene, x, y, target, tetherUnit) { super(scene, x, y, 0xff8888, 40, 110, target); this.attackRange = 180; this.tetherUnit = tetherUnit; }
    update() {
        if(this.isDead) return; this.preUpdate();
        if (this.tetherUnit && !this.tetherUnit.isDead) { let distToMaster = Phaser.Math.Distance.Between(this.x, this.y, this.tetherUnit.x, this.tetherUnit.y); if (distToMaster > 300) { this.scene.physics.moveToObject(this, this.tetherUnit, this.speed * 1.3); return; } }
        let combatTarget = this.findAggroTarget(); let finalTarget = combatTarget || this.moveTarget;
        if (!combatTarget && this.moveTarget instanceof Village) { let distToVillage = Phaser.Math.Distance.Between(this.x, this.y, this.moveTarget.x, this.moveTarget.y); if (distToVillage < this.moveTarget.siegeRadius) { this.body.setVelocity(0); return; } }
        if (finalTarget && !finalTarget.isDead) { let dist = Phaser.Math.Distance.Between(this.x, this.y, finalTarget.x, finalTarget.y); if (dist > this.attackRange) { this.scene.physics.moveToObject(this, finalTarget, this.speed); } else { this.body.setVelocity(0); if (Date.now() - this.lastAttackTime > 1500) { projectiles.add(new Projectile(this.scene, this.x, this.y, finalTarget, 10, true)); this.lastAttackTime = Date.now(); } } }
    }
}

class Carriage extends EnemyUnit {
    constructor(scene, startX, startY, endX, endY) { 
        super(scene, startX, startY, 0xffd700, 300, 30, null); 
        this.width = 40; this.height = 60; 
        this.targetPos = new Phaser.Math.Vector2(endX, endY); 
        this.body.setCollideWorldBounds(true); 
        this.body.setCircle(15, 5, 15); 
        this.body.setImmovable(true); 
        this.hpBarBg.destroy(); this.hpBar.destroy(); 
        this.hpBarBg = scene.add.rectangle(this.x, this.y, 40, 4, 0x000000).setDepth(1); 
        this.hpBar = scene.add.rectangle(this.x, this.y, 40, 4, 0x00ff00).setDepth(1); 
    }
    update() {
        if(this.isDead) return; 
        this.preUpdate();
        let dist = Phaser.Math.Distance.Between(this.x, this.y, this.targetPos.x, this.targetPos.y);
        if (dist < 10) { this.destroy(); } else { this.scene.physics.moveTo(this, this.targetPos.x, this.targetPos.y, this.speed); }
    }
    die() { updateGold(600); updateRep(150); showToast(this.scene, "Êê∂Âæó $600 + 150 Rep!", "gold"); super.die(); }
}

class Manor {
    constructor(scene, x, y, type) {
        this.scene = scene; this.x = x; this.y = y; this.type = type; 
        this.maxGuards = 8; this.spawnTimer = 0; this.destroyed = false;
        this.building = scene.add.rectangle(x, y, 80, 80, 0x800080); 
        scene.physics.add.existing(this.building, true);
        obstacles.add(this.building);
        this.core = new EnemyUnit(scene, x, y, 0x000000, 1000, 0, null); 
        this.core.setSize(80, 80); this.core.body.setSize(80, 80); this.core.body.setImmovable(true); this.core.setVisible(false);
        enemies.add(this.core);
        this.core.die = () => {
            this.core.isDead = true; this.core.hpBar.destroy(); this.core.hpBarBg.destroy();
            if (Math.random() < 0.5) loots.add(new Loot(this.scene, this.x, this.y, 'gold'));
            const particles = this.scene.add.particles(this.x, this.y, 'pixel', { speed: 150, scale: { start: 2, end: 0 }, lifespan: 800, blendMode: 'ADD', tint: 0x800080, quantity: 20 });
            this.scene.time.delayedCall(800, () => particles.destroy());
            this.core.destroy(); this.destroyManor();
        };
        let label = (type === 'gold') ? "ÈªÉÈáëËéäÂúí" : "Ë≤¥ÊóèËéäÂúí";
        this.label = scene.add.text(x, y-60, label, {fontSize:'16px', fontWeight:'bold', color:'violet'}).setOrigin(0.5);
    }
    update(delta) {
        if (this.destroyed || this.core.isDead) return;
        let guards = 0; enemies.children.iterate(e => { if(e.tetherUnit === this.core) guards++; });
        if (guards < this.maxGuards) {
            this.spawnTimer += delta;
            if (this.spawnTimer > 5000) {
                let px = this.x + Phaser.Math.Between(-60, 60); let py = this.y + Phaser.Math.Between(-60, 60);
                if (Math.random() < 0.3) enemies.add(new EnemyArcher(this.scene, px, py, player, this.core));
                else enemies.add(new EnemySoldier(this.scene, px, py, player, this.core));
                this.spawnTimer = 0;
            }
        }
    }
    destroyManor() {
        this.destroyed = true; this.building.fillColor = 0x333333; 
        this.label.setText("Â∑≤ÊëßÊØÄ"); this.label.setColor("#aaa");
        if (this.type === 'gold') { permanentBuffs.gold = true; document.getElementById('buff-gold').style.display = 'inline'; showToast(this.scene, "Áç≤ÂæóÈªÉÈáëËÅñÊùØÔºÅ(ÊØèÁßí+$)", "gold"); } else { permanentBuffs.rep = true; document.getElementById('buff-rep').style.display = 'inline'; showToast(this.scene, "Áç≤ÂæóË≤¥ÊóèÂç∞Á´†ÔºÅ(ÊØèÁßí+Rep)", "cyan"); }
        updateGold(1000); updateRep(500);
    }
}

class Deer extends Unit {
    constructor(scene, x, y) { super(scene, x, y, 16, 16, 0xc2b280, 15); this.speed=40; this.timer=0; this.body.setCollideWorldBounds(true); }
    update() { if(this.isDead)return; this.preUpdate(); this.timer++; if(this.timer>100){ if(Math.random()>0.3) this.scene.physics.velocityFromAngle(Phaser.Math.Between(0,360),40,this.body.velocity); else this.body.setVelocity(0); this.timer=0; } }
    die() { updateGold(15); super.die(); }
}

class Wolf extends Unit {
    constructor(scene, x, y) { super(scene, x, y, 20, 20, 0x808080, 40); this.speed=100; this.body.setCollideWorldBounds(true); this.attackRange = 40; }
    update() { 
        if(this.isDead)return; this.preUpdate(); 
        let target = null; let minDist = 200;
        let d = Phaser.Math.Distance.Between(this.x, this.y, player.x, player.y);
        if (d < minDist) { minDist = d; target = player; }
        squad.children.iterate(s => { if(s && !s.isDead) { let sd = Phaser.Math.Distance.Between(this.x, this.y, s.x, s.y); if (sd < minDist) { minDist = sd; target = s; } } });
        wildLife.children.iterate(w => { if(w instanceof Deer && !w.isDead) { let wd = Phaser.Math.Distance.Between(this.x, this.y, w.x, w.y); if (wd < minDist) { minDist = wd; target = w; } } });
        if (target) {
            if (minDist <= this.attackRange) {
                this.body.setVelocity(0);
                if (Date.now() - this.lastAttackTime > 1000) { projectiles.add(new MeleeSlash(this.scene, this.x, this.y, target, 10, true)); this.lastAttackTime = Date.now(); }
            } else this.scene.physics.moveToObject(this, target, this.speed);
        } else { if (Math.random() < 0.02) this.scene.physics.velocityFromAngle(Phaser.Math.Between(0,360), 50, this.body.velocity); }
    }
    die() { updateGold(25); super.die(); }
}

class TownGuard extends Soldier {
    constructor(scene, x, y, village) {
        super(scene, x, y);
        this.fillColor = 0x8888ff; // Ê∑±ËóçËâ≤
        this.village = village;
        this.hp = 100; this.maxHp = 100;
        this.detectRange = 250;
    }
    update(player, isAutoMode) {
        if(this.isDead) return; this.preUpdate();
        
        let distToVillage = Phaser.Math.Distance.Between(this.x, this.y, this.village.x, this.village.y);
        if (distToVillage > 150) {
            this.scene.physics.moveTo(this, this.village.x, this.village.y, this.speed * 1.5);
            return;
        }
        
        let target = this.findTarget(enemies, this.detectRange);
        if (target) {
            let dist = Phaser.Math.Distance.Between(this.x, this.y, target.x, target.y);
            if (dist <= this.attackRange) { 
                this.body.setVelocity(0); 
                if (Date.now() - this.lastAttackTime > 800) { 
                    projectiles.add(new MeleeSlash(this.scene, this.x, this.y, target, 20, false)); 
                    this.lastAttackTime = Date.now(); 
                } 
            } 
            else { this.scene.physics.moveToObject(this, target, this.speed); }
        } else {
            if (distToVillage > 50) this.scene.physics.moveTo(this, this.village.x, this.village.y, this.speed * 0.5);
            else this.body.setVelocity(0);
        }
    }
}

class WanderingChampion extends Unit {
    constructor(scene, x, y) {
        super(scene, x, y, 32, 32, 0x9932cc, 500, 500); 
        this.speed = 120;
        this.detectRange = 250;
        this.attackRange = 50;
        this.isRecruited = false;
        this.body.setCircle(16);
        this.body.setMass(50);
        this.hpBar.fillColor = 0xff00ff;
    }
    
    update() {
        if (this.isDead) return;
        this.preUpdate();
        
        let target = null;
        let minDist = this.detectRange;
        
        let groups = [squad, enemies, wildLife];
        groups.forEach(g => {
            g.children.iterate(u => {
                if (u && !u.isDead && u.body) {
                    let d = Phaser.Math.Distance.Between(this.x, this.y, u.x, u.y);
                    if (d < minDist) { minDist = d; target = u; }
                }
            });
        });
        
        let dp = Phaser.Math.Distance.Between(this.x, this.y, player.x, player.y);
        if (dp < minDist) { minDist = dp; target = player; }
        
        if (target) {
            if (minDist <= this.attackRange) {
                this.body.setVelocity(0);
                if (Date.now() - this.lastAttackTime > 600) {
                    projectiles.add(new MeleeSlash(this.scene, this.x, this.y, target, 40, true));
                    this.lastAttackTime = Date.now();
                }
            } else {
                this.scene.physics.moveToObject(this, target, this.speed);
            }
        } else {
            if (Math.random() < 0.02) this.scene.physics.velocityFromAngle(Phaser.Math.Between(0,360), 60, this.body.velocity);
        }
    }
    
    die() {
        if (!this.isRecruited) {
            this.isRecruited = true;
            this.isDead = false; 
            this.hp = this.maxHp;
            this.fillColor = 0xffd700; 
            this.hpBar.fillColor = 0x00ff00;
            this.width = 24; this.height = 24; 
            this.body.setCircle(12);
            
            neutrals.remove(this);
            squad.add(this);
            
            this.update = function(player, isAutoMode) {
                if(this.isDead) return; this.preUpdate();
                if (!isAutoMode) { 
                    let d = Phaser.Math.Distance.Between(this.x, this.y, player.x, player.y); 
                    if (d > 60) this.scene.physics.moveTo(this, player.x, player.y, this.speed); else this.body.setVelocity(0);
                    return; 
                }
                
                let t = null; let md = 300;
                enemies.children.iterate(u => { if (u && !u.isDead) { let d = Phaser.Math.Distance.Between(this.x, this.y, u.x, u.y); if (d < md) { md = d; t = u; } } });
                
                if (t) {
                    let d = Phaser.Math.Distance.Between(this.x, this.y, t.x, t.y);
                    if (d <= 50) {
                        this.body.setVelocity(0);
                        if (Date.now() - this.lastAttackTime > 600) {
                            projectiles.add(new MeleeSlash(this.scene, this.x, this.y, t, 50, false));
                            this.lastAttackTime = Date.now();
                        }
                    } else this.scene.physics.moveToObject(this, t, this.speed * 1.3);
                } else {
                    let d = Phaser.Math.Distance.Between(this.x, this.y, player.x, player.y); 
                    if (d > 60) this.scene.physics.moveTo(this, player.x, player.y, this.speed); else this.body.setVelocity(0);
                }
            };
            
            showToast(this.scene, "ÂäçËÅñÂä†ÂÖ•‰∫Ü‰Ω†ÁöÑÈöä‰ºçÔºÅ", "gold");
        } else {
            super.die();
        }
    }
}

class Village {
    constructor(scene, x, y, name) {
        this.scene = scene; this.x = x; this.y = y; this.name = name;
        this.level = 1; this.stock = 3; this.maxStock = 3; this.passiveTimer = 0; this.stockTimer = 0;
        this.zones = { upgrade: { x: x, y: y - 60, r: 30, color: 0xffff00, timer: 0, required: 3000, action: 'upgrade', label: 'ÂçáÁ¥ö' }, soldier: { x: x - 50, y: y + 50, r: 30, color: 0x0000ff, timer: 0, required: 1000, action: 'recruit_h', label: 'Ê≠•ÂÖµ' }, archer: { x: x + 50, y: y + 50, r: 30, color: 0x00ffff, timer: 0, required: 1000, action: 'recruit_j', label: 'ÂºìÊâã' } };
        this.siegeRadius = 90; this.integrity = 100; this.maxIntegrity = 100;
        this.siegeZone = scene.add.circle(x, y, this.siegeRadius, 0xff0000, 0.1); scene.physics.add.existing(this.siegeZone, true);
        this.siegeBar = scene.add.rectangle(x, y + 20, 60, 6, 0x00ff00).setOrigin(0.5);
        this.building = scene.add.rectangle(x, y, 60, 60, 0x8b4513); scene.physics.add.existing(this.building, true); obstacles.add(this.building);
        this.zoneGraphics = scene.add.graphics(); this.drawZones();
        this.nameText = scene.add.text(x, y - 40, name, {fontSize: '16px', fontWeight:'bold'}).setOrigin(0.5);
        this.statusText = scene.add.text(x, y - 25, "Lv.1 | 3/3", {fontSize: '12px', color:'#fff', backgroundColor:'#000'}).setOrigin(0.5);
    }
    drawZones() { this.zoneGraphics.clear(); for (let key in this.zones) { let z = this.zones[key]; this.zoneGraphics.lineStyle(2, z.color, 0.5); this.zoneGraphics.strokeCircle(z.x, z.y, z.r); if (z.timer > 0) { let pct = z.timer / z.required; this.zoneGraphics.fillStyle(0xffffff, 0.5); this.zoneGraphics.fillCircle(z.x, z.y, z.r * pct); } } }
    update(delta, enemies) {
        let playerDist = (gx, gy) => Phaser.Math.Distance.Between(player.x, player.y, gx, gy); let redraw = false;
        for (let key in this.zones) { let z = this.zones[key]; if (playerDist(z.x, z.y) < z.r) { z.timer += delta; redraw = true; if (z.timer >= z.required) { this.executeAction(z.action); z.timer = 0; } } else { if (z.timer > 0) { z.timer = 0; redraw = true; } } }
        if (redraw) this.drawZones();
        let siegeCount = 0; enemies.children.iterate(e => { if (e && !e.isDead && Phaser.Math.Distance.Between(this.x, this.y, e.x, e.y) < this.siegeRadius) siegeCount++; });
        if (siegeCount > 0 && this.level > 1) { this.integrity -= siegeCount * (delta/1000) * 5; if (this.integrity <= 0) this.downgrade(); this.siegeZone.fillColor = 0xff0000; this.siegeZone.fillAlpha = 0.3; } else { if (this.integrity < this.maxIntegrity) this.integrity += (delta/1000) * 2; this.siegeZone.fillColor = 0x000000; this.siegeZone.fillAlpha = 0.05; }
        this.siegeBar.width = 60 * (this.integrity / this.maxIntegrity); this.siegeBar.fillColor = (siegeCount > 0) ? 0xff0000 : 0x00ff00;
        if (this.level > 1) { this.passiveTimer += delta; if (this.passiveTimer > 5000) { let income = (this.level - 1) * 5; updateRep(income); this.passiveTimer = 0; } }
        if (this.stock < this.maxStock) { this.stockTimer += delta; if (this.stockTimer > 6000) { this.stock++; this.refreshVisuals(); this.stockTimer = 0; } }
    }
    executeAction(action) { if (action === 'upgrade') this.upgrade(); else if (action === 'recruit_h') { if(this.recruit('H')) squad.add(new Soldier(this.scene, player.x, player.y)); } else if (action === 'recruit_j') { if(this.recruit('J')) squad.add(new Archer(this.scene, player.x, player.y)); } }
    upgrade() { 
        if (this.level >= 5) return false; 
        let cost = this.level * G.upgradeCostFactor; 
        if (gold >= cost) { 
            updateGold(-cost); this.level++; this.integrity = 100; this.maxStock = 2 + this.level; this.stock = this.maxStock; 
            this.refreshVisuals(); showToast(this.scene, `${this.name} ÂçáÁ¥öËá≥ Lv.${this.level}!`, "cyan"); 
            if (this.level === 5) {
                for(let i=0; i<2; i++) squad.add(new TownGuard(this.scene, this.x + Phaser.Math.Between(-30,30), this.y + Phaser.Math.Between(-30,30), this));
                for(let i=0; i<2; i++) squad.add(new Archer(this.scene, this.x + Phaser.Math.Between(-30,30), this.y + Phaser.Math.Between(-30,30))); 
                showToast(this.scene, "ÈßêÂÆàË°õÈöäÂ∑≤ÈÉ®ÁΩ≤ÔºÅ", "gold");
            }
            return true; 
        } 
        return false; 
    }
    downgrade() { this.level = 1; this.integrity = 100; updateRep(-200); showToast(this.scene, `${this.name} Ë¢´ÊîªÈô∑‰∫ÜÔºÅ`, "red"); this.refreshVisuals(); }
    recruit(type) { 
        if (this.stock <= 0) return false; 
        let cost = (type === 'H') ? G.costSoldier : G.costArcher; 
        if (gold >= cost) { updateGold(-cost); this.stock--; this.refreshVisuals(); showToast(this.scene, `ÊãõÂãüÊàêÂäü (-$${cost})`, "lime"); return true; } return false; 
    }
    refreshVisuals() { this.statusText.setText(`Lv.${this.level} | ${this.stock}/${this.maxStock}`); let colors = [0x8b4513, 0xcd853f, 0xd2691e, 0xa0522d, 0x800000]; this.building.fillColor = colors[this.level-1] || 0x8b4513; }
}

class GameDirector {
    constructor(scene) { this.scene = scene; this.timers = { patrol: 0, caravan: 0, passive: 0 }; }
    update(delta) {
        if (isGameOver) return;
        this.timers.patrol += delta; this.timers.caravan += delta; this.timers.passive += delta;
        if (this.timers.passive > 1000) { if (permanentBuffs.gold) updateGold(5); if (permanentBuffs.rep) updateRep(2); this.timers.passive = 0; }
        let timeFactor = (300 - gameTimeLeft) / 60; let repFactor = reputation / 500; let difficulty = 1 + (timeFactor * 0.5) + (repFactor * 0.5);
        let baseInterval = G.patrolBaseInterval;
        let patrolInterval = Math.max(10000, baseInterval - (difficulty * 4000));
        if (this.timers.patrol > patrolInterval) { this.spawnPatrol(difficulty); this.timers.patrol = 0; }
        if (this.timers.caravan > 35000) { this.spawnCaravan(difficulty); this.timers.caravan = 0; }
    }
    spawnPatrol(difficulty) {
        let targets = [player]; villages.forEach(v => { if(v.level > 1) targets.push(v); }); let target = targets[Phaser.Math.Between(0, targets.length-1)];
        let msg = (target === player) ? "Â∑°ÈÇèÈöäÊ≠£Âú®ÊêúÊçï‰Ω†ÔºÅ" : `Â∑°ÈÇèÈöäÊ≠£Âú®ÂâçÂæÄ ${target.name}ÔºÅ`; showToast(this.scene, msg, "red");
        let count = Math.floor(2 + difficulty); let pos = getRandomEdgePos(this.scene, 100);
        for(let i=0; i<count; i++) { let px = pos.x + Phaser.Math.Between(-30,30); let py = pos.y + Phaser.Math.Between(-30,30); if (Math.random() < 0.3) enemies.add(new EnemyArcher(this.scene, px, py, target)); else enemies.add(new EnemySoldier(this.scene, px, py, target)); }
    }
    spawnCaravan(difficulty) {
        let startX, startY, endX, endY; if (Math.random() > 0.5) { startX = 50; startY = Phaser.Math.Between(200, 1800); endX = 1950; endY = Phaser.Math.Between(200, 1800); } else { startX = Phaser.Math.Between(200, 1800); startY = 50; endX = Phaser.Math.Between(200, 1800); endY = 1950; }
        let carriage = new Carriage(this.scene, startX, startY, endX, endY); enemies.add(carriage);
        let guardCount = Math.floor(2 + difficulty); for(let i=0; i<guardCount; i++) { let px = startX + Phaser.Math.Between(-30,30); let py = startY + Phaser.Math.Between(-30,30); if (Math.random() < 0.3) enemies.add(new EnemyArcher(this.scene, px, py, player, carriage)); else enemies.add(new EnemySoldier(this.scene, px, py, player, carriage)); }
    }
}

const config = {
    type: Phaser.AUTO, width: window.innerWidth, height: window.innerHeight, parent: 'game-container',
    physics: { default: 'arcade', arcade: { gravity: { y: 0 }, debug: false } },
    scene: { preload: preload, create: create, update: update },
    backgroundColor: '#3b7d4f'
};

game = new Phaser.Game(config);

function preload() {
    this.load.spritesheet('player', 'https://raw.githubusercontent.com/darkbearlab/gunFightSurvivor/refs/heads/main/player.png', { frameWidth: 32, frameHeight: 32 });
    const graphics = this.make.graphics({x: 0, y: 0, add: false}); graphics.fillStyle(0xffffff, 1); graphics.fillRect(0, 0, 4, 4); graphics.generateTexture('pixel', 4, 4);
}

function getRandomEdgePos(scene, margin) { let x, y; if (Math.random() > 0.5) { x = Math.random() > 0.5 ? margin : 2000 - margin; y = Phaser.Math.Between(margin, 2000 - margin); } else { y = Math.random() > 0.5 ? margin : 2000 - margin; x = Phaser.Math.Between(margin, 2000 - margin); } return {x, y}; }

function create() {
    this.physics.world.setBounds(0, 0, 2000, 2000);
    this.add.grid(1000, 1000, 2000, 2000, 50, 50, 0x3b7d4f, 0, 0x000000, 0.1);

    obstacles = this.physics.add.staticGroup();
    squad = this.add.group({ runChildUpdate: false });
    enemies = this.add.group({ runChildUpdate: false });
    wildLife = this.add.group({ runChildUpdate: false });
    projectiles = this.add.group({ runChildUpdate: false });
    loots = this.add.group({ runChildUpdate: false });
    neutrals = this.add.group({ runChildUpdate: false });

    this.anims.create({ key: 'walk-down', frames: this.anims.generateFrameNumbers('player', { start: 0, end: 3 }), frameRate: 8, repeat: -1 });
    this.anims.create({ key: 'walk-left', frames: this.anims.generateFrameNumbers('player', { start: 4, end: 7 }), frameRate: 8, repeat: -1 });
    this.anims.create({ key: 'walk-right', frames: this.anims.generateFrameNumbers('player', { start: 8, end: 11 }), frameRate: 8, repeat: -1 });
    this.anims.create({ key: 'walk-up', frames: this.anims.generateFrameNumbers('player', { start: 12, end: 15 }), frameRate: 8, repeat: -1 });

    for (let i = 0; i < 80; i++) {
        let tx = Phaser.Math.Between(50, 1950); let ty = Phaser.Math.Between(50, 1950); let clear = true;
        [[400,400], [1000,1000], [1600,1600], [200,1800], [1800,200]].forEach(p => { if(Math.abs(tx-p[0])<150 && Math.abs(ty-p[1])<150) clear = false; });
        if (clear) { let tree = this.add.rectangle(tx, ty, 40, 40, 0x1e4726); this.physics.add.existing(tree, true); tree.body.setCircle(20); obstacles.add(tree); }
    }

    villages = [ new Village(this, 400, 400, "ÂåóÂ¢ÉÊùë"), new Village(this, 1000, 1000, "‰∏≠Â§ÆÂ∏ÇÈõÜ"), new Village(this, 1600, 1600, "ÂçóÈ¢®ÈéÆ") ];
    manors = [ new Manor(this, 200, 1800, 'gold'), new Manor(this, 1800, 200, 'rep') ];

    player = new Hero(this, 1000, 1100);
    this.cameras.main.startFollow(player, true, 0.09, 0.09); this.cameras.main.setZoom(1.0);
    
    neutrals.add(new WanderingChampion(this, 1500, 500));

    for(let i=0; i<12; i++) { let p=getRandomEdgePos(this, 100); wildLife.add(new Deer(this, p.x, p.y)); }
    for(let i=0; i<5; i++) { let p=getRandomEdgePos(this, 100); wildLife.add(new Wolf(this, p.x, p.y)); }

    this.physics.add.collider(player, obstacles); this.physics.add.collider(player, enemies); this.physics.add.collider(player, wildLife); this.physics.add.collider(player, neutrals);
    this.physics.add.collider(squad, obstacles); this.physics.add.collider(enemies, obstacles);
    this.physics.add.collider(wildLife, obstacles); this.physics.add.collider(neutrals, obstacles);
    this.physics.add.collider(squad, squad);
    this.physics.add.collider(squad, enemies); this.physics.add.collider(squad, neutrals);
    this.physics.add.collider(enemies, neutrals);

    this.physics.add.overlap(projectiles, enemies, (p, e) => { if(!p.isEnemy) { e.takeDamage(p.damage); p.destroy(); } });
    this.physics.add.overlap(projectiles, wildLife, (p, e) => { if(!p.isEnemy) { e.takeDamage(p.damage); p.destroy(); } });
    this.physics.add.overlap(projectiles, neutrals, (p, e) => { if(!p.isEnemy) { e.takeDamage(p.damage); p.destroy(); } });
    this.physics.add.overlap(projectiles, squad, (p, s) => { if(p.isEnemy) { s.takeDamage(p.damage); p.destroy(); } });
    this.physics.add.overlap(projectiles, player, (p, h) => { if(p.isEnemy) { h.takeDamage(p.damage); p.destroy(); } });
    this.physics.add.overlap(player, loots, (p, l) => l.pickup());

    uiTexts.gold = document.getElementById('gold-display');
    uiTexts.squad = document.getElementById('squad-count');
    uiTexts.enemy = document.getElementById('enemy-count');
    uiTexts.rep = document.getElementById('rep-display');
    uiTexts.repBar = document.getElementById('rep-bar');
    updateGold(0); updateRep(0);

    cursors = this.input.keyboard.createCursorKeys();
    wasd = this.input.keyboard.addKeys({ up: 'W', down: 'S', left: 'A', right: 'D' });
    
    director = new GameDirector(this);
    
    this.time.addEvent({ delay: 1000, callback: () => {
        if (!isGameOver && isGameStarted) {
            gameTimeLeft--;
            let m = Math.floor(gameTimeLeft/60); let s = gameTimeLeft%60;
            document.getElementById('time-display').innerText = `${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;
            checkGameOver();
        }
    }, loop: true });
    
    joyGraphics = this.add.graphics().setScrollFactor(0).setDepth(999);
    this.input.on('pointerdown', (pointer) => { 
        if(!isGameStarted) return;
        if (pointer.y > window.innerHeight - 100 && pointer.x > window.innerWidth - 100) return; 
        joyStick.active = true; joyStick.startX = pointer.x; joyStick.startY = pointer.y; joyStick.currX = pointer.x; joyStick.currY = pointer.y; joyStick.vec.set(0, 0); 
    });
    this.input.on('pointermove', (pointer) => { 
        if (joyStick.active) { joyStick.currX = pointer.x; joyStick.currY = pointer.y; let dx = pointer.x - joyStick.startX; let dy = pointer.y - joyStick.startY; let dist = Math.sqrt(dx*dx + dy*dy); let maxDist = 50; if (dist > maxDist) { let ratio = maxDist / dist; joyStick.currX = joyStick.startX + dx * ratio; joyStick.currY = joyStick.startY + dy * ratio; } if (dist > 5) joyStick.vec.set(dx, dy).normalize(); else joyStick.vec.set(0, 0); } 
    });
    this.input.on('pointerup', () => { joyStick.active = false; joyStick.vec.set(0, 0); joyGraphics.clear(); });
}

function update(time, delta) {
    if (!isGameStarted || isGameOver) return;
    
    if (joyStick.active) { joyGraphics.clear(); joyGraphics.lineStyle(2, 0xffffff, 0.5); joyGraphics.strokeCircle(joyStick.startX, joyStick.startY, 50); joyGraphics.fillStyle(0xffffff, 0.8); joyGraphics.fillCircle(joyStick.currX, joyStick.currY, 20); } else joyGraphics.clear();
    player.update();
    director.update(delta);
    villages.forEach(v => v.update(delta, enemies));
    manors.forEach(m => m.update(delta));
    squad.children.iterate(u => u && u.update(player, isAutoAttackMode));
    enemies.children.iterate(u => u && u.update && u.update());
    wildLife.children.iterate(u => u && u.update && u.update());
    neutrals.children.iterate(u => u && u.update && u.update());
    projectiles.children.iterate(p => p && p.update());
    uiTexts.squad.innerText = squad.countActive(true);
    uiTexts.enemy.innerText = enemies.countActive(true);
}

window.addEventListener('resize', () => game.scale.resize(window.innerWidth, window.innerHeight));
</script>

</body>
</html>
