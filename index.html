<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ç¾…è³“æ¼¢æˆ°è¨˜ - Phase 11 (Fixed)</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
    <style>
        body { 
            margin: 0; padding: 0; background-color: #2d2d2d; overflow: hidden; 
            font-family: 'Segoe UI', sans-serif; 
            user-select: none; -webkit-user-select: none; 
            touch-action: none;
        }
        #game-container { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; }
        
        #ui-layer {
            position: absolute; top: 10px; left: 10px; right: 10px; color: white; pointer-events: none;
            text-shadow: 1px 1px 2px black;
            display: flex; flex-direction: column; gap: 5px;
            z-index: 10;
        }
        
        .hud-box {
            background-color: rgba(0, 0, 0, 0.6); padding: 10px; border-radius: 8px;
            pointer-events: auto;
        }

        #game-over-screen {
            display: none; position: absolute; top: 0; left: 0; width: 100vw; height: 100vh;
            background: rgba(0,0,0,0.85); color: white; z-index: 20;
            flex-direction: column; justify-content: center; align-items: center; text-align: center;
        }
        #game-over-title { font-size: 3em; margin-bottom: 20px; font-weight: bold; }
        button.restart-btn { margin-top: 30px; padding: 15px 40px; font-size: 1.5em; cursor: pointer; background: gold; border: none; border-radius: 8px; font-weight: bold; }
        
        #mobile-controls {
            position: absolute; bottom: 20px; right: 20px; z-index: 15; pointer-events: auto;
        }
        #mode-btn {
            width: 80px; height: 80px; border-radius: 50%; border: 4px solid white;
            background-color: rgba(0, 255, 0, 0.5); color: white; font-weight: bold; font-size: 14px;
            display: flex; justify-content: center; align-items: center; text-align: center;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5); cursor: pointer; user-select: none;
            transition: transform 0.1s;
        }
        #mode-btn:active { transform: scale(0.95); }

        .stat-row { display: flex; justify-content: space-between; margin-bottom: 2px; font-size: 14px; }
        .bar-container { width: 100%; background: #444; height: 8px; border-radius: 4px; margin-top: 2px; overflow: hidden; }
        .bar-fill { height: 100%; background: lime; width: 0%; transition: width 0.5s; }
        .buff-icon { display: none; margin-right: 5px; color: gold; font-weight: bold; }
    </style>
</head>
<body>

<div id="ui-layer">
    <div class="hud-box">
        <div class="stat-row">
            <span>â³ <span id="time-display" style="color: cyan;">05:00</span></span>
            <span>ğŸ’° <span id="gold-display" style="color: gold;">0</span></span>
        </div>
        <div>
            åè²: <span id="rep-display">0</span> / 3000
            <div class="bar-container"><div id="rep-bar" class="bar-fill"></div></div>
        </div>
        <div style="margin-top:5px; font-size:12px; color:#aaa; display: flex; align-items: center;">
            <span style="margin-right: 10px;">éƒ¨éšŠ: <span id="squad-count">0</span> | æ•µè»: <span id="enemy-count">0</span></span>
            <span id="buff-gold" class="buff-icon">ğŸ†é‡‘æ¯</span>
            <span id="buff-rep" class="buff-icon">ğŸ“œå°ç« </span>
        </div>
    </div>
</div>

<div id="mobile-controls">
    <div id="mode-btn" onclick="toggleMode()">ğŸ›¡ï¸<br>è·Ÿéš¨</div>
</div>

<div id="game-over-screen">
    <div id="game-over-title">GAME OVER</div>
    <div id="game-over-desc" style="padding: 0 20px;"></div>
    <button class="restart-btn" onclick="location.reload()">å†ç©ä¸€æ¬¡</button>
</div>

<div id="game-container"></div>

<script>
// --- å…¨åŸŸè¨­å®š ---
const GAME_DURATION = 300; 
const TARGET_REP = 3000;

let game, player, director;
let gold = 300; 
let reputation = 0;
let isAutoAttackMode = false;
let gameTimeLeft = GAME_DURATION;
let isGameOver = false;
let permanentBuffs = { gold: false, rep: false };

let joyStick = { active: false, startX: 0, startY: 0, currX: 0, currY: 0, vec: new Phaser.Math.Vector2(0,0) };

let squad, enemies, wildLife, obstacles, projectiles, loots;
let villages = [];
let manors = [];
let uiTexts = {}; 
let cursors, wasd, keys;
let joyGraphics;

function toggleMode() {
    isAutoAttackMode = !isAutoAttackMode;
    const btn = document.getElementById('mode-btn');
    if (isAutoAttackMode) {
        btn.innerHTML = "âš”ï¸<br>æ”»æ“Š";
        btn.style.backgroundColor = "rgba(255, 0, 0, 0.6)";
    } else {
        btn.innerHTML = "ğŸ›¡ï¸<br>è·Ÿéš¨";
        btn.style.backgroundColor = "rgba(0, 255, 0, 0.5)";
    }
}

function updateGold(amount) {
    gold += amount;
    uiTexts.gold.innerText = Math.floor(gold);
}

function updateRep(amount) {
    reputation += amount;
    if (reputation < 0) reputation = 0;
    uiTexts.rep.innerText = Math.floor(reputation);
    let pct = Math.min((reputation / TARGET_REP) * 100, 100);
    uiTexts.repBar.style.width = pct + "%";
}

function showDamageText(scene, x, y, amount, color = '#fff') {
    let text = scene.add.text(x, y - 20, amount, {
        fontSize: '16px', color: color, stroke: '#000', strokeThickness: 3, fontWeight: 'bold'
    }).setOrigin(0.5).setDepth(20);
    scene.tweens.add({ targets: text, y: y - 50, alpha: 0, duration: 800, onComplete: () => text.destroy() });
}

function showToast(scene, msg, color) {
    let text = scene.add.text(player.x, player.y - 150, msg, {
        fontSize: '20px', color: color, stroke: '#000', strokeThickness: 4, backgroundColor: 'rgba(0,0,0,0.6)', padding: {x:10, y:5}
    }).setOrigin(0.5).setDepth(100);
    scene.tweens.add({ targets: text, y: player.y - 200, alpha: 0, duration: 3000, onComplete: () => text.destroy() });
}

function checkGameOver() {
    if (isGameOver) return;
    if (gameTimeLeft <= 0) {
        if (reputation >= TARGET_REP) endGame(true, "å‚³å¥‡èª•ç”Ÿï¼<br>ä½ æˆåŠŸæŠµæŠ—äº†æš´æ”¿ï¼Œä¸¦å»ºç«‹äº†æ–°çš„ç§©åºã€‚");
        else endGame(false, "èµ·ç¾©å¤±æ•—ã€‚<br>éš¨è‘—ç…å¿ƒç‹æ­¸åœ‹ï¼Œä½ çš„åå­—è¢«éºå¿˜åœ¨æ­·å²ä¸­ã€‚");
    }
}

function endGame(victory, message) {
    isGameOver = true;
    game.scene.pause("default");
    const screen = document.getElementById('game-over-screen');
    const title = document.getElementById('game-over-title');
    const desc = document.getElementById('game-over-desc');
    screen.style.display = 'flex';
    title.innerText = victory ? "VICTORY!" : "DEFEAT";
    title.style.color = victory ? "gold" : "red";
    desc.innerHTML = message;
}

// --- é“å…· ---
class Loot extends Phaser.GameObjects.Text {
    constructor(scene, x, y, type) {
        let icon = 'ğŸ’°';
        if (type === 'heal') icon = 'â¤ï¸';
        else if (type === 'buff') icon = 'âš”ï¸';
        super(scene, x, y, icon, { fontSize: '20px' });
        scene.add.existing(this); scene.physics.add.existing(this);
        this.type = type; this.bornTime = Date.now();
        scene.tweens.add({ targets: this, y: y - 5, duration: 500, yoyo: true, repeat: -1 });
    }
    pickup() {
        if (this.type === 'heal') { player.hp = Math.min(player.hp + 50, player.maxHp); showDamageText(this.scene, player.x, player.y, "+50 HP", "#0f0"); } 
        else if (this.type === 'gold') { updateGold(50); updateRep(10); showDamageText(this.scene, player.x, player.y, "+$50", "gold"); } 
        else if (this.type === 'buff') { player.activateBuff(); showToast(this.scene, "æ”»æ“ŠåŠ›æå‡!", "red"); }
        this.destroy();
    }
}

// --- å–®ä½ ---
class Unit extends Phaser.GameObjects.Rectangle {
    constructor(scene, x, y, width, height, color, hp, maxHp) {
        super(scene, x, y, width, height, color);
        scene.add.existing(this); scene.physics.add.existing(this);
        const radius = width / 2; this.body.setCircle(radius); this.body.setCollideWorldBounds(true); this.body.setBounce(0); this.body.setDrag(100); this.body.setMass(1);
        this.hp = hp; this.maxHp = maxHp || hp; this.isDead = false; this.lastAttackTime = 0;
        this.hpBarBg = scene.add.rectangle(x, y - height, width, 4, 0x000000).setDepth(1);
        this.hpBar = scene.add.rectangle(x, y - height, width, 4, 0x00ff00).setDepth(1);
    }
    preUpdate() { if (this.isDead) return; this.hpBarBg.setPosition(this.x, this.y - this.height/2 - 5); this.hpBar.setPosition(this.x, this.y - this.height/2 - 5); }
    takeDamage(amount) { if (this.isDead) return; this.scene.tweens.add({ targets: this, alpha: 0.2, duration: 50, yoyo: true, repeat: 1 }); this.hp -= amount; showDamageText(this.scene, this.x, this.y, amount); const pct = Math.max(0, this.hp / this.maxHp); this.hpBar.width = this.width * pct; if (pct < 0.3) this.hpBar.fillColor = 0xff0000; else if (pct < 0.6) this.hpBar.fillColor = 0xffff00; if (this.hp <= 0) this.die(); }
    die() {
        this.isDead = true; this.hpBar.destroy(); this.hpBarBg.destroy();
        if (Math.random() < 0.2) { let r = Math.random(); let type = 'gold'; if (r < 0.4) type = 'heal'; else if (r < 0.5) type = 'buff'; loots.add(new Loot(this.scene, this.x, this.y, type)); }
        const particles = this.scene.add.particles(this.x, this.y, 'pixel', { speed: 100, scale: { start: 1, end: 0 }, lifespan: 500, blendMode: 'ADD', tint: this.fillColor });
        this.scene.time.delayedCall(500, () => particles.destroy());
        this.destroy();
    }
}

class Projectile extends Phaser.GameObjects.Rectangle {
    constructor(scene, x, y, target, damage, isEnemy, speed, lifeTime, color) {
        super(scene, x, y, 10, 4, color || (isEnemy ? 0xff4444 : 0xffff00));
        scene.add.existing(this); scene.physics.add.existing(this);
        this.damage = damage; this.isEnemy = isEnemy; this.bornTime = Date.now(); this.lifeTime = lifeTime || 1000;
        const angle = Phaser.Math.Angle.Between(x, y, target.x, target.y); this.rotation = angle;
        scene.physics.velocityFromRotation(angle, speed || 400, this.body.velocity);
    }
    update() { if (Date.now() - this.bornTime > this.lifeTime) this.destroy(); }
}

class MeleeSlash extends Projectile {
    constructor(scene, x, y, target, damage, isEnemy) {
        super(scene, x, y, target, damage, isEnemy, 600, 150, 0xffffff);
        this.width = 16; this.height = 16; 
        scene.tweens.add({ targets: this, scaleX: 1.5, scaleY: 1.5, alpha: 0, duration: 150 });
    }
}

class Hero extends Phaser.Physics.Arcade.Sprite {
    constructor(scene, x, y) {
        super(scene, x, y, 'player', 0);
        scene.add.existing(this); scene.physics.add.existing(this); this.setScale(1.0);
        this.body.setCircle(12, 4, 8); this.body.setCollideWorldBounds(true); this.body.setMass(100); 
        this.hp = 300; this.maxHp = 300; this.isDead = false; this.lastAttackTime = 0;
        this.speed = 220; this.detectRange = 100; this.attackCooldown = 500; this.damageMultiplier = 1; this.buffTimer = 0;
        this.hpBarBg = scene.add.rectangle(x, y - 30, 40, 4, 0x000000).setDepth(1);
        this.hpBar = scene.add.rectangle(x, y - 30, 40, 4, 0x00ff00).setDepth(1);
        this.play('walk-down', true); this.anims.stop();
    }
    preUpdate(time, delta) {
        super.preUpdate(time, delta); if (this.isDead) return;
        this.hpBarBg.setPosition(this.x, this.y - 30); this.hpBar.setPosition(this.x, this.y - 30);
        if (this.buffTimer > 0) { this.buffTimer -= delta; if (this.buffTimer <= 0) { this.damageMultiplier = 1; this.clearTint(); } }
    }
    activateBuff() { this.buffTimer = 10000; this.damageMultiplier = 2; this.setTint(0xff0000); }
    move() {
        this.body.setVelocity(0); let vx = 0, vy = 0;
        if (cursors.left.isDown || wasd.left.isDown) vx = -1; else if (cursors.right.isDown || wasd.right.isDown) vx = 1;
        if (cursors.up.isDown || wasd.up.isDown) vy = -1; else if (cursors.down.isDown || wasd.down.isDown) vy = 1;
        if (joyStick.active) { vx = joyStick.vec.x; vy = joyStick.vec.y; }
        if (vx !== 0 || vy !== 0) {
            let v = new Phaser.Math.Vector2(vx, vy).normalize().scale(this.speed); this.body.setVelocity(v.x, v.y);
            if (Math.abs(vy) >= Math.abs(vx)) { if (vy > 0) this.play('walk-down', true); else this.play('walk-up', true); } else { if (vx > 0) this.play('walk-right', true); else this.play('walk-left', true); }
        } else { this.anims.stop(); }
    }
    update() {
        if(this.isDead) return; this.move();
        if (Date.now() - this.lastAttackTime > this.attackCooldown) {
            let target = this.findTarget(enemies, this.detectRange); if (!target) target = this.findTarget(wildLife, this.detectRange);
            if (target) { let dmg = 25 * this.damageMultiplier; projectiles.add(new MeleeSlash(this.scene, this.x, this.y, target, dmg, false)); this.lastAttackTime = Date.now(); }
        }
    }
    findTarget(group, range) { let target = null; let minDist = range; group.children.iterate(u => { if (u && !u.isDead && u.body) { let d = Phaser.Math.Distance.Between(this.x, this.y, u.x, u.y); if (d < minDist) { minDist = d; target = u; } } }); return target; }
    takeDamage(amount) { if (this.isDead) return; this.scene.tweens.add({ targets: this, alpha: 0.2, duration: 50, yoyo: true, repeat: 1 }); this.hp -= amount; showDamageText(this.scene, this.x, this.y, amount); const pct = Math.max(0, this.hp / this.maxHp); this.hpBar.width = 40 * pct; if (pct < 0.3) this.hpBar.fillColor = 0xff0000; else if (pct < 0.6) this.hpBar.fillColor = 0xffff00; if (this.hp <= 0) this.die(); }
    die() { this.isDead = true; this.hpBar.destroy(); this.hpBarBg.destroy(); this.destroy(); endGame(false, "ä½ æˆ°æ­»æ²™å ´ï¼Œé©å‘½ä¹‹ç«ç†„æ»…äº†ã€‚"); }
}

class Soldier extends Unit {
    constructor(scene, x, y) { super(scene, x, y, 20, 20, 0x33ccff, 60, 60); this.speed = 180; this.detectRange = 300; this.guardRange = 120; this.attackRange = 40; this.wanderOffset = new Phaser.Math.Vector2(Phaser.Math.Between(-50,50), Phaser.Math.Between(-50,50)); }
    update(player, isAutoMode) {
        if(this.isDead) return; this.preUpdate();
        if (!isAutoMode) { this.follow(player, false); return; }
        let target = this.findTarget(enemies, this.detectRange); if (!target && isAutoMode) target = this.findTarget(wildLife, this.detectRange);
        if (target) { let dist = Phaser.Math.Distance.Between(this.x, this.y, target.x, target.y); if (dist <= this.attackRange) { this.body.setVelocity(0); if (Date.now() - this.lastAttackTime > 800) { projectiles.add(new MeleeSlash(this.scene, this.x, this.y, target, 15 * (player.damageMultiplier || 1), false)); this.lastAttackTime = Date.now(); } } else { this.scene.physics.moveToObject(this, target, this.speed * 1.2); } } else { this.follow(player, isAutoMode); }
    }
    findTarget(group, range) { let target = null; let minDist = range; group.children.iterate(u => { if (u && !u.isDead && u.body) { let d = Phaser.Math.Distance.Between(this.x, this.y, u.x, u.y); if (d < minDist) { minDist = d; target = u; } } }); return target; }
    follow(player, isAutoMode) { let d = Phaser.Math.Distance.Between(this.x, this.y, player.x, player.y); if (d > 60) this.scene.physics.moveTo(this, player.x + this.wanderOffset.x, player.y + this.wanderOffset.y, this.speed); else this.body.setVelocity(0); }
}
class Archer extends Unit {
    constructor(scene, x, y) { super(scene, x, y, 16, 16, 0x00ffff, 30, 30); this.speed = 160; this.detectRange = 350; this.attackRange = 180; this.wanderOffset = new Phaser.Math.Vector2(Phaser.Math.Between(-50,50), Phaser.Math.Between(-50,50)); }
    update(player, isAutoMode) {
        if(this.isDead) return; this.preUpdate();
        if (!isAutoMode) { this.follow(player, false); return; }
        let target = this.findTarget(enemies, this.detectRange); if (!target && isAutoMode) target = this.findTarget(wildLife, this.detectRange);
        if (target) { let d = Phaser.Math.Distance.Between(this.x, this.y, target.x, target.y); if (d > this.attackRange) { this.scene.physics.moveToObject(this, target, this.speed); } else { this.body.setVelocity(0); if (Date.now() - this.lastAttackTime > 1200) { projectiles.add(new Projectile(this.scene, this.x, this.y, target, 15 * (player.damageMultiplier || 1), false)); this.lastAttackTime = Date.now(); } } } else { this.follow(player, isAutoMode); }
    }
    findTarget(group, range) { let target = null; let minDist = range; group.children.iterate(u => { if (u && !u.isDead && u.body) { let d = Phaser.Math.Distance.Between(this.x, this.y, u.x, u.y); if (d < minDist) { minDist = d; target = u; } } }); return target; }
    follow(player, isAutoMode) { let d = Phaser.Math.Distance.Between(this.x, this.y, player.x, player.y); if (d > 70) this.scene.physics.moveTo(this, player.x + this.wanderOffset.x, player.y + this.wanderOffset.y, this.speed); else this.body.setVelocity(0); }
}

class EnemyUnit extends Unit {
    constructor(scene, x, y, color, hp, speed, target) { super(scene, x, y, 20, 20, color, hp, hp); this.moveTarget = target; this.speed = speed; this.attackRange = 40; }
    findAggroTarget() { let target = null; let minDist = 200; let d = Phaser.Math.Distance.Between(this.x, this.y, player.x, player.y); if (d < minDist) { minDist = d; target = player; } squad.children.iterate(s => { if(s && !s.isDead) { let sd = Phaser.Math.Distance.Between(this.x, this.y, s.x, s.y); if (sd < minDist) { minDist = sd; target = s; } } }); return target; }
}
class EnemySoldier extends EnemyUnit {
    constructor(scene, x, y, target, tetherUnit) { super(scene, x, y, 0xff4444, 60, 130, target); this.tetherUnit = tetherUnit; }
    update() {
        if(this.isDead) return; this.preUpdate();
        if (this.tetherUnit && !this.tetherUnit.isDead) { let distToMaster = Phaser.Math.Distance.Between(this.x, this.y, this.tetherUnit.x, this.tetherUnit.y); if (distToMaster > 300) { this.scene.physics.moveToObject(this, this.tetherUnit, this.speed * 1.3); return; } }
        let combatTarget = this.findAggroTarget(); let finalTarget = combatTarget || this.moveTarget;
        if (this.moveTarget instanceof Village) { let distToVillage = Phaser.Math.Distance.Between(this.x, this.y, this.moveTarget.x, this.moveTarget.y); if (distToVillage < this.moveTarget.siegeRadius) { if (!combatTarget) { this.body.setVelocity(0); return; } } }
        if (finalTarget && !finalTarget.isDead) { let dist = Phaser.Math.Distance.Between(this.x, this.y, finalTarget.x, finalTarget.y); if (dist <= this.attackRange) { this.body.setVelocity(0); if (Date.now() - this.lastAttackTime > 1000) { projectiles.add(new MeleeSlash(this.scene, this.x, this.y, finalTarget, 10, true)); this.lastAttackTime = Date.now(); } } else this.scene.physics.moveToObject(this, finalTarget, this.speed); }
    }
}
class EnemyArcher extends EnemyUnit {
    constructor(scene, x, y, target, tetherUnit) { super(scene, x, y, 0xff8888, 40, 110, target); this.attackRange = 180; this.tetherUnit = tetherUnit; }
    update() {
        if(this.isDead) return; this.preUpdate();
        if (this.tetherUnit && !this.tetherUnit.isDead) { let distToMaster = Phaser.Math.Distance.Between(this.x, this.y, this.tetherUnit.x, this.tetherUnit.y); if (distToMaster > 300) { this.scene.physics.moveToObject(this, this.tetherUnit, this.speed * 1.3); return; } }
        let combatTarget = this.findAggroTarget(); let finalTarget = combatTarget || this.moveTarget;
        if (!combatTarget && this.moveTarget instanceof Village) { let distToVillage = Phaser.Math.Distance.Between(this.x, this.y, this.moveTarget.x, this.moveTarget.y); if (distToVillage < this.moveTarget.siegeRadius) { this.body.setVelocity(0); return; } }
        if (finalTarget && !finalTarget.isDead) { let dist = Phaser.Math.Distance.Between(this.x, this.y, finalTarget.x, finalTarget.y); if (dist > this.attackRange) { this.scene.physics.moveToObject(this, finalTarget, this.speed); } else { this.body.setVelocity(0); if (Date.now() - this.lastAttackTime > 1500) { projectiles.add(new Projectile(this.scene, this.x, this.y, finalTarget, 10, true)); this.lastAttackTime = Date.now(); } } }
    }
}
class Carriage extends EnemyUnit {
    constructor(scene, startX, startY, endX, endY) { super(scene, startX, startY, 0xffd700, 300, 30, null); this.width = 40; this.height = 60; this.targetPos = new Phaser.Math.Vector2(endX, endY); this.body.setCollideWorldBounds(true); this.body.setCircle(25, -5, 5); this.body.setMass(1000); this.hpBarBg.destroy(); this.hpBar.destroy(); this.hpBarBg = scene.add.rectangle(this.x, this.y, 40, 4, 0x000000).setDepth(1); this.hpBar = scene.add.rectangle(this.x, this.y, 40, 4, 0x00ff00).setDepth(1); }
    update() { if(this.isDead) return; this.preUpdate(); let dist = Phaser.Math.Distance.Between(this.x, this.y, this.targetPos.x, this.targetPos.y); if (dist < 10) { this.destroy(); } else { this.scene.physics.moveTo(this, this.targetPos.x, this.targetPos.y, this.speed); } }
    die() { updateGold(600); updateRep(150); showToast(this.scene, "æ¶å¾— $600 + 150 Rep!", "gold"); super.die(); }
}

// [ä¿®æ­£] Manor é‚è¼¯ä¿®æ­£ï¼šæ ¸å¿ƒæ­»äº¡è™•ç†
class Manor {
    constructor(scene, x, y, type) {
        this.scene = scene; this.x = x; this.y = y; this.type = type; 
        this.maxGuards = 8; this.spawnTimer = 0; this.destroyed = false;
        
        // å»ºç¯‰ (Visual & Obstacle)
        this.building = scene.add.rectangle(x, y, 80, 80, 0x800080); // ç´«è‰²
        scene.physics.add.existing(this.building, true);
        obstacles.add(this.building);
        
        // æ ¸å¿ƒè¡€é‡ (Hitbox & Health)
        // [ä¿®æ­£] æ ¸å¿ƒå¤§å°èˆ‡å»ºç¯‰ä¸€è‡´ï¼Œç¢ºä¿å¥½æ‰“
        this.core = new EnemyUnit(scene, x, y, 0x000000, 1000, 0, null); 
        this.core.setSize(80, 80); 
        this.core.body.setSize(80, 80); 
        this.core.body.setImmovable(true);
        this.core.setVisible(false);
        enemies.add(this.core);
        
        // [é—œéµä¿®æ­£] è¦†å¯« die æ–¹æ³•ä»¥ç¢ºä¿è§¸ç™¼ destroyManor
        // é€™è£¡ä¸èƒ½ç”¨ superï¼Œæ‰€ä»¥æ‰‹å‹•è™•ç†æ­»äº¡é‚è¼¯
        this.core.die = () => {
            this.core.isDead = true;
            this.core.hpBar.destroy();
            this.core.hpBarBg.destroy();
            
            // æ‰å¯¶é‚è¼¯
            if (Math.random() < 0.5) loots.add(new Loot(this.scene, this.x, this.y, 'gold'));
            
            // ç²’å­ç‰¹æ•ˆ
            const particles = this.scene.add.particles(this.x, this.y, 'pixel', { speed: 150, scale: { start: 2, end: 0 }, lifespan: 800, blendMode: 'ADD', tint: 0x800080, quantity: 20 });
            this.scene.time.delayedCall(800, () => particles.destroy());
            
            this.core.destroy();
            this.destroyManor(); // è§¸ç™¼èŠåœ’éŠ·æ¯€
        };
        
        let label = (type === 'gold') ? "é»ƒé‡‘èŠåœ’" : "è²´æ—èŠåœ’";
        this.label = scene.add.text(x, y-60, label, {fontSize:'16px', fontWeight:'bold', color:'violet'}).setOrigin(0.5);
    }
    
    update(delta) {
        if (this.destroyed || this.core.isDead) return;
        
        let guards = 0;
        enemies.children.iterate(e => { if(e.tetherUnit === this.core) guards++; });
        
        if (guards < this.maxGuards) {
            this.spawnTimer += delta;
            if (this.spawnTimer > 5000) {
                let px = this.x + Phaser.Math.Between(-60, 60); let py = this.y + Phaser.Math.Between(-60, 60);
                if (Math.random() < 0.3) enemies.add(new EnemyArcher(this.scene, px, py, player, this.core));
                else enemies.add(new EnemySoldier(this.scene, px, py, player, this.core));
                this.spawnTimer = 0;
            }
        }
    }
    
    destroyManor() {
        this.destroyed = true;
        this.building.fillColor = 0x333333; // [ä¿®æ­£] è®Šæ·±ç°
        this.label.setText("å·²æ‘§æ¯€");
        this.label.setColor("#aaa");
        
        if (this.type === 'gold') {
            permanentBuffs.gold = true;
            document.getElementById('buff-gold').style.display = 'inline'; // é¡¯ç¤º UI
            showToast(this.scene, "ç²å¾—é»ƒé‡‘è–æ¯ï¼(æ¯ç§’+$)", "gold");
        } else {
            permanentBuffs.rep = true;
            document.getElementById('buff-rep').style.display = 'inline'; // é¡¯ç¤º UI
            showToast(this.scene, "ç²å¾—è²´æ—å°ç« ï¼(æ¯ç§’+Rep)", "cyan");
        }
        updateGold(1000);
        updateRep(500);
    }
}

class Deer extends Unit { constructor(scene, x, y) { super(scene, x, y, 16, 16, 0xc2b280, 15); this.speed=40; this.timer=0; this.body.setCollideWorldBounds(true); } update() { if(this.isDead)return; this.preUpdate(); this.timer++; if(this.timer>100){ if(Math.random()>0.3) this.scene.physics.velocityFromAngle(Phaser.Math.Between(0,360),40,this.body.velocity); else this.body.setVelocity(0); this.timer=0; } } die() { updateGold(15); super.die(); } }
class Wolf extends Unit { constructor(scene, x, y) { super(scene, x, y, 20, 20, 0x808080, 40); this.speed=100; this.body.setCollideWorldBounds(true); this.attackRange = 40; } update() { if(this.isDead)return; this.preUpdate(); let target = null; let minDist = 200; let d = Phaser.Math.Distance.Between(this.x, this.y, player.x, player.y); if (d < minDist) { minDist = d; target = player; } squad.children.iterate(s => { if(s && !s.isDead) { let sd = Phaser.Math.Distance.Between(this.x, this.y, s.x, s.y); if (sd < minDist) { minDist = sd; target = s; } } }); wildLife.children.iterate(w => { if(w instanceof Deer && !w.isDead) { let wd = Phaser.Math.Distance.Between(this.x, this.y, w.x, w.y); if (wd < minDist) { minDist = wd; target = w; } } }); if (target) { if (minDist <= this.attackRange) { this.body.setVelocity(0); if (Date.now() - this.lastAttackTime > 1000) { projectiles.add(new MeleeSlash(this.scene, this.x, this.y, target, 10, true)); this.lastAttackTime = Date.now(); } } else this.scene.physics.moveToObject(this, target, this.speed); } else { if (Math.random() < 0.02) this.scene.physics.velocityFromAngle(Phaser.Math.Between(0,360), 50, this.body.velocity); } } die() { updateGold(25); super.die(); } }

class Village {
    constructor(scene, x, y, name) {
        this.scene = scene; this.x = x; this.y = y; this.name = name;
        this.level = 1; this.stock = 3; this.maxStock = 3; this.passiveTimer = 0; this.stockTimer = 0;
        this.zones = { upgrade: { x: x, y: y - 60, r: 30, color: 0xffff00, timer: 0, required: 3000, action: 'upgrade', label: 'å‡ç´š' }, soldier: { x: x - 50, y: y + 50, r: 30, color: 0x0000ff, timer: 0, required: 1000, action: 'recruit_h', label: 'æ­¥å…µ' }, archer: { x: x + 50, y: y + 50, r: 30, color: 0x00ffff, timer: 0, required: 1000, action: 'recruit_j', label: 'å¼“æ‰‹' } };
        this.siegeRadius = 90; this.integrity = 100; this.maxIntegrity = 100;
        this.siegeZone = scene.add.circle(x, y, this.siegeRadius, 0xff0000, 0.1); scene.physics.add.existing(this.siegeZone, true);
        this.siegeBar = scene.add.rectangle(x, y + 20, 60, 6, 0x00ff00).setOrigin(0.5);
        this.building = scene.add.rectangle(x, y, 60, 60, 0x8b4513); scene.physics.add.existing(this.building, true); obstacles.add(this.building);
        this.zoneGraphics = scene.add.graphics(); this.drawZones();
        this.nameText = scene.add.text(x, y - 40, name, {fontSize: '16px', fontWeight:'bold'}).setOrigin(0.5);
        this.statusText = scene.add.text(x, y - 25, "Lv.1 | 3/3", {fontSize: '12px', color:'#fff', backgroundColor:'#000'}).setOrigin(0.5);
    }
    drawZones() { this.zoneGraphics.clear(); for (let key in this.zones) { let z = this.zones[key]; this.zoneGraphics.lineStyle(2, z.color, 0.5); this.zoneGraphics.strokeCircle(z.x, z.y, z.r); if (z.timer > 0) { let pct = z.timer / z.required; this.zoneGraphics.fillStyle(0xffffff, 0.5); this.zoneGraphics.fillCircle(z.x, z.y, z.r * pct); } } }
    update(delta, enemies) {
        let playerDist = (gx, gy) => Phaser.Math.Distance.Between(player.x, player.y, gx, gy); let redraw = false;
        for (let key in this.zones) { let z = this.zones[key]; if (playerDist(z.x, z.y) < z.r) { z.timer += delta; redraw = true; if (z.timer >= z.required) { this.executeAction(z.action); z.timer = 0; } } else { if (z.timer > 0) { z.timer = 0; redraw = true; } } }
        if (redraw) this.drawZones();
        let siegeCount = 0; enemies.children.iterate(e => { if (e && !e.isDead && Phaser.Math.Distance.Between(this.x, this.y, e.x, e.y) < this.siegeRadius) siegeCount++; });
        if (siegeCount > 0 && this.level > 1) { this.integrity -= siegeCount * (delta/1000) * 5; if (this.integrity <= 0) this.downgrade(); this.siegeZone.fillColor = 0xff0000; this.siegeZone.fillAlpha = 0.3; } else { if (this.integrity < this.maxIntegrity) this.integrity += (delta/1000) * 2; this.siegeZone.fillColor = 0x000000; this.siegeZone.fillAlpha = 0.05; }
        this.siegeBar.width = 60 * (this.integrity / this.maxIntegrity); this.siegeBar.fillColor = (siegeCount > 0) ? 0xff0000 : 0x00ff00;
        if (this.level > 1) { this.passiveTimer += delta; if (this.passiveTimer > 5000) { let income = (this.level - 1) * 5; updateRep(income); this.passiveTimer = 0; } }
        if (this.stock < this.maxStock) { this.stockTimer += delta; if (this.stockTimer > 6000) { this.stock++; this.refreshVisuals(); this.stockTimer = 0; } }
    }
    executeAction(action) { if (action === 'upgrade') this.upgrade(); else if (action === 'recruit_h') { if(this.recruit('H')) squad.add(new Soldier(this.scene, player.x, player.y)); } else if (action === 'recruit_j') { if(this.recruit('J')) squad.add(new Archer(this.scene, player.x, player.y)); } }
    upgrade() { if (this.level >= 5) return false; let cost = this.level * 100; if (gold >= cost) { updateGold(-cost); this.level++; this.integrity = 100; this.maxStock = 2 + this.level; this.stock = this.maxStock; this.refreshVisuals(); showToast(this.scene, `${this.name} å‡ç´šè‡³ Lv.${this.level}!`, "cyan"); return true; } return false; }
    downgrade() { this.level = 1; this.integrity = 100; updateRep(-200); showToast(this.scene, `${this.name} è¢«æ”»é™·äº†ï¼`, "red"); this.refreshVisuals(); }
    recruit(type) { if (this.stock <= 0) return false; let cost = (type === 'H') ? 20 : 30; if (gold >= cost) { updateGold(-cost); this.stock--; this.refreshVisuals(); showToast(this.scene, `æ‹›å‹ŸæˆåŠŸ (-$${cost})`, "lime"); return true; } return false; }
    refreshVisuals() { this.statusText.setText(`Lv.${this.level} | ${this.stock}/${this.maxStock}`); let colors = [0x8b4513, 0xcd853f, 0xd2691e, 0xa0522d, 0x800000]; this.building.fillColor = colors[this.level-1] || 0x8b4513; }
}

class GameDirector {
    constructor(scene) { this.scene = scene; this.timers = { patrol: 0, caravan: 0, passive: 0 }; }
    update(delta) {
        if (isGameOver) return;
        this.timers.patrol += delta; this.timers.caravan += delta; this.timers.passive += delta;
        if (this.timers.passive > 1000) { if (permanentBuffs.gold) updateGold(5); if (permanentBuffs.rep) updateRep(2); this.timers.passive = 0; }
        let timeFactor = (300 - gameTimeLeft) / 60; let repFactor = reputation / 500; let difficulty = 1 + (timeFactor * 0.5) + (repFactor * 0.5);
        let patrolInterval = Math.max(10000, 40000 - (difficulty * 4000));
        if (this.timers.patrol > patrolInterval) { this.spawnPatrol(difficulty); this.timers.patrol = 0; }
        if (this.timers.caravan > 35000) { this.spawnCaravan(difficulty); this.timers.caravan = 0; }
    }
    spawnPatrol(difficulty) {
        let targets = [player]; villages.forEach(v => { if(v.level > 1) targets.push(v); }); let target = targets[Phaser.Math.Between(0, targets.length-1)];
        let msg = (target === player) ? "å·¡é‚éšŠæ­£åœ¨æœæ•ä½ ï¼" : `å·¡é‚éšŠæ­£åœ¨å‰å¾€ ${target.name}ï¼`; showToast(this.scene, msg, "red");
        let count = Math.floor(2 + difficulty); let pos = getRandomEdgePos(this.scene, 100);
        for(let i=0; i<count; i++) { let px = pos.x + Phaser.Math.Between(-30,30); let py = pos.y + Phaser.Math.Between(-30,30); if (Math.random() < 0.3) enemies.add(new EnemyArcher(this.scene, px, py, target)); else enemies.add(new EnemySoldier(this.scene, px, py, target)); }
    }
    spawnCaravan(difficulty) {
        let startX, startY, endX, endY; if (Math.random() > 0.5) { startX = 50; startY = Phaser.Math.Between(200, 1800); endX = 1950; endY = Phaser.Math.Between(200, 1800); } else { startX = Phaser.Math.Between(200, 1800); startY = 50; endX = Phaser.Math.Between(200, 1800); endY = 1950; }
        let carriage = new Carriage(this.scene, startX, startY, endX, endY); enemies.add(carriage);
        let guardCount = Math.floor(2 + difficulty); for(let i=0; i<guardCount; i++) { let px = startX + Phaser.Math.Between(-30,30); let py = startY + Phaser.Math.Between(-30,30); if (Math.random() < 0.3) enemies.add(new EnemyArcher(this.scene, px, py, player, carriage)); else enemies.add(new EnemySoldier(this.scene, px, py, player, carriage)); }
    }
}

const config = {
    type: Phaser.AUTO, width: window.innerWidth, height: window.innerHeight, parent: 'game-container',
    physics: { default: 'arcade', arcade: { gravity: { y: 0 }, debug: false } },
    scene: { preload: preload, create: create, update: update },
    backgroundColor: '#3b7d4f'
};

game = new Phaser.Game(config);

function preload() {
    this.load.spritesheet('player', 'https://raw.githubusercontent.com/darkbearlab/gunFightSurvivor/refs/heads/main/player.png', { frameWidth: 32, frameHeight: 32 });
    const graphics = this.make.graphics({x: 0, y: 0, add: false}); graphics.fillStyle(0xffffff, 1); graphics.fillRect(0, 0, 4, 4); graphics.generateTexture('pixel', 4, 4);
}

function getRandomEdgePos(scene, margin) { let x, y; if (Math.random() > 0.5) { x = Math.random() > 0.5 ? margin : 2000 - margin; y = Phaser.Math.Between(margin, 2000 - margin); } else { y = Math.random() > 0.5 ? margin : 2000 - margin; x = Phaser.Math.Between(margin, 2000 - margin); } return {x, y}; }

function create() {
    this.physics.world.setBounds(0, 0, 2000, 2000);
    this.add.grid(1000, 1000, 2000, 2000, 50, 50, 0x3b7d4f, 0, 0x000000, 0.1);

    obstacles = this.physics.add.staticGroup();
    squad = this.add.group({ runChildUpdate: false });
    enemies = this.add.group({ runChildUpdate: false });
    wildLife = this.add.group({ runChildUpdate: false });
    projectiles = this.add.group({ runChildUpdate: false });
    loots = this.add.group({ runChildUpdate: false });

    this.anims.create({ key: 'walk-down', frames: this.anims.generateFrameNumbers('player', { start: 0, end: 3 }), frameRate: 8, repeat: -1 });
    this.anims.create({ key: 'walk-left', frames: this.anims.generateFrameNumbers('player', { start: 4, end: 7 }), frameRate: 8, repeat: -1 });
    this.anims.create({ key: 'walk-right', frames: this.anims.generateFrameNumbers('player', { start: 8, end: 11 }), frameRate: 8, repeat: -1 });
    this.anims.create({ key: 'walk-up', frames: this.anims.generateFrameNumbers('player', { start: 12, end: 15 }), frameRate: 8, repeat: -1 });

    for (let i = 0; i < 80; i++) {
        let tx = Phaser.Math.Between(50, 1950); let ty = Phaser.Math.Between(50, 1950); let clear = true;
        [[400,400], [1000,1000], [1600,1600], [200,1800], [1800,200]].forEach(p => { if(Math.abs(tx-p[0])<150 && Math.abs(ty-p[1])<150) clear = false; });
        if (clear) { let tree = this.add.rectangle(tx, ty, 40, 40, 0x1e4726); this.physics.add.existing(tree, true); tree.body.setCircle(20); obstacles.add(tree); }
    }

    villages = [ new Village(this, 400, 400, "åŒ—å¢ƒæ‘"), new Village(this, 1000, 1000, "ä¸­å¤®å¸‚é›†"), new Village(this, 1600, 1600, "å—é¢¨é®") ];
    manors = [ new Manor(this, 200, 1800, 'gold'), new Manor(this, 1800, 200, 'rep') ];

    player = new Hero(this, 1000, 1100);
    this.cameras.main.startFollow(player, true, 0.09, 0.09); this.cameras.main.setZoom(1.0);
    
    for(let i=0; i<12; i++) { let p=getRandomEdgePos(this, 100); wildLife.add(new Deer(this, p.x, p.y)); }
    for(let i=0; i<5; i++) { let p=getRandomEdgePos(this, 100); wildLife.add(new Wolf(this, p.x, p.y)); }

    this.physics.add.collider(player, obstacles); this.physics.add.collider(player, enemies); this.physics.add.collider(player, wildLife);
    this.physics.add.collider(squad, obstacles); this.physics.add.collider(enemies, obstacles);
    this.physics.add.collider(wildLife, obstacles);
    this.physics.add.collider(squad, squad);
    this.physics.add.collider(squad, enemies);

    this.physics.add.overlap(projectiles, enemies, (p, e) => { if(!p.isEnemy) { e.takeDamage(p.damage); p.destroy(); } });
    this.physics.add.overlap(projectiles, wildLife, (p, e) => { if(!p.isEnemy) { e.takeDamage(p.damage); p.destroy(); } });
    this.physics.add.overlap(projectiles, squad, (p, s) => { if(p.isEnemy) { s.takeDamage(p.damage); p.destroy(); } });
    this.physics.add.overlap(projectiles, player, (p, h) => { if(p.isEnemy) { h.takeDamage(p.damage); p.destroy(); } });
    this.physics.add.overlap(player, loots, (p, l) => l.pickup());

    uiTexts.gold = document.getElementById('gold-display');
    uiTexts.squad = document.getElementById('squad-count');
    uiTexts.enemy = document.getElementById('enemy-count');
    uiTexts.rep = document.getElementById('rep-display');
    uiTexts.repBar = document.getElementById('rep-bar');
    updateGold(0); updateRep(0);

    cursors = this.input.keyboard.createCursorKeys();
    wasd = this.input.keyboard.addKeys({ up: 'W', down: 'S', left: 'A', right: 'D' });
    
    director = new GameDirector(this);
    
    this.time.addEvent({ delay: 1000, callback: () => {
        if (!isGameOver) {
            gameTimeLeft--;
            let m = Math.floor(gameTimeLeft/60); let s = gameTimeLeft%60;
            document.getElementById('time-display').innerText = `${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;
            checkGameOver();
        }
    }, loop: true });
    
    joyGraphics = this.add.graphics().setScrollFactor(0).setDepth(999);
    this.input.on('pointerdown', (pointer) => { if (pointer.y > window.innerHeight - 100 && pointer.x > window.innerWidth - 100) return; joyStick.active = true; joyStick.startX = pointer.x; joyStick.startY = pointer.y; joyStick.currX = pointer.x; joyStick.currY = pointer.y; joyStick.vec.set(0, 0); });
    this.input.on('pointermove', (pointer) => { if (joyStick.active) { joyStick.currX = pointer.x; joyStick.currY = pointer.y; let dx = pointer.x - joyStick.startX; let dy = pointer.y - joyStick.startY; let dist = Math.sqrt(dx*dx + dy*dy); let maxDist = 50; if (dist > maxDist) { let ratio = maxDist / dist; joyStick.currX = joyStick.startX + dx * ratio; joyStick.currY = joyStick.startY + dy * ratio; } if (dist > 5) joyStick.vec.set(dx, dy).normalize(); else joyStick.vec.set(0, 0); } });
    this.input.on('pointerup', () => { joyStick.active = false; joyStick.vec.set(0, 0); joyGraphics.clear(); });
}

function update(time, delta) {
    if (isGameOver) return;
    if (joyStick.active) { joyGraphics.clear(); joyGraphics.lineStyle(2, 0xffffff, 0.5); joyGraphics.strokeCircle(joyStick.startX, joyStick.startY, 50); joyGraphics.fillStyle(0xffffff, 0.8); joyGraphics.fillCircle(joyStick.currX, joyStick.currY, 20); } else joyGraphics.clear();
    player.update();
    director.update(delta);
    villages.forEach(v => v.update(delta, enemies));
    manors.forEach(m => m.update(delta));
    squad.children.iterate(u => u && u.update(player, isAutoAttackMode));
    enemies.children.iterate(u => u && u.update && u.update());
    wildLife.children.iterate(u => u && u.update && u.update());
    projectiles.children.iterate(p => p && p.update());
    uiTexts.squad.innerText = squad.countActive(true);
    uiTexts.enemy.innerText = enemies.countActive(true);
}

window.addEventListener('resize', () => game.scale.resize(window.innerWidth, window.innerHeight));
</script>

</body>
</html>
