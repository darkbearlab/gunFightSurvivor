<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser-arcade-physics.min.js"></script>
    <style>
        body { margin: 0; background: #222; font-family: 'Arial', sans-serif; overflow: hidden; touch-action: none; user-select: none; -webkit-user-select: none; }
        #game-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; pointer-events: none; }
        .btn {
            position: absolute; background: rgba(255, 255, 255, 0.2); border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 10px; pointer-events: auto; touch-action: none;
            display: flex; align-items: center; justify-content: center;
            color: white; font-weight: bold; font-size: 24px; user-select: none;
        }
        .btn:active { background: rgba(255, 255, 255, 0.5); }
        #dpad { position: absolute; bottom: 20px; left: 20px; width: 150px; height: 150px; }
        #btn-up { top: 0; left: 50px; width: 50px; height: 50px; }
        #btn-down { bottom: 0; left: 50px; width: 50px; height: 50px; }
        #btn-left { top: 50px; left: 0; width: 50px; height: 50px; }
        #btn-right { top: 50px; right: 0; width: 50px; height: 50px; }
        #btn-fire { 
            position: absolute; bottom: 40px; right: 40px; 
            width: 80px; height: 80px; border-radius: 50%; 
            background: rgba(255, 0, 0, 0.3); border-color: rgba(255, 0, 0, 0.6);
        }
        #btn-fire:active { background: rgba(255, 0, 0, 0.6); }
        #hud { position: absolute; top: 10px; left: 10px; color: white; text-shadow: 1px 1px 2px black; pointer-events: none; }
    </style>
</head>
<body>
    <div id="game-container"></div>
    <div id="ui-layer">
        <div id="hud"><div id="hud-ammo">Ammo: 0</div><div id="hud-score">Score: 0</div><div id="hud-time">Time: 60</div></div>
        <div id="dpad">
            <div id="btn-up" class="btn">↑</div><div id="btn-down" class="btn">↓</div>
            <div id="btn-left" class="btn">←</div><div id="btn-right" class="btn">→</div>
        </div>
        <div id="btn-fire" class="btn">FIRE</div>
    </div>

    <script>
        class MyGame extends Phaser.Scene {
            constructor() {
                super();
                this.playerSpeed = 200;
                this.enemySpeed = 100;
                this.playerAmmo = 50;
                this.maxPlayerAmmo = 100;
                this.playerScore = 0;
                this.gameTimer = 60;
                this.gameOver = false;
                this.inputs = { up: false, down: false, left: false, right: false };
                this.lastFacing = 0; 
            }

            preload() {
                // [修改點 1] 換成新的完整 Sprite Sheet 網址
                this.load.spritesheet('player', 
                    'https://raw.githubusercontent.com/darkbearlab/gunFightSurvivor/refs/heads/main/player.png', 
                    { frameWidth: 32, frameHeight: 32 }
                );

                this.createTexture('enemy', 24, 24, 0xff0000);
                this.createTexture('bullet', 10, 10, 0xffff00);
                this.createTexture('ammoPack', 16, 16, 0x00ffff);
            }

            createTexture(key, w, h, color) {
                const g = this.make.graphics({ x: 0, y: 0, add: false });
                g.fillStyle(color, 1); g.fillRect(0, 0, w, h); g.generateTexture(key, w, h);
            }

            create() {
                this.physics.world.setBounds(0, 0, 2000, 2000);
                
                // [修改點 2] 定義四個方向的動畫
                // 向下走 (Row 0)
                this.anims.create({
                    key: 'walk-down',
                    frames: this.anims.generateFrameNumbers('player', { start: 0, end: 3 }),
                    frameRate: 10,
                    repeat: -1
                });
                // 向左走 (Row 1)
                this.anims.create({
                    key: 'walk-left',
                    frames: this.anims.generateFrameNumbers('player', { start: 4, end: 7 }),
                    frameRate: 10,
                    repeat: -1
                });
                // 向右走 (Row 2)
                this.anims.create({
                    key: 'walk-right',
                    frames: this.anims.generateFrameNumbers('player', { start: 8, end: 11 }),
                    frameRate: 10,
                    repeat: -1
                });
                // 向上走 (Row 3)
                this.anims.create({
                    key: 'walk-up',
                    frames: this.anims.generateFrameNumbers('player', { start: 12, end: 15 }),
                    frameRate: 10,
                    repeat: -1
                });


                this.player = this.physics.add.sprite(1000, 1000, 'player');
                this.player.setCollideWorldBounds(true);
                this.player.setScale(1.5); 
                // 預設播放向下走的動畫，讓它一開始有圖案
                this.player.anims.play('walk-down');
                this.player.anims.stop(); 

                this.cameras.main.startFollow(this.player, true, 0.05, 0.05);
                this.cameras.main.setBounds(0, 0, 2000, 2000);

                this.enemies = this.physics.add.group({ classType: Enemy, runChildUpdate: true });
                this.bullets = this.physics.add.group({ classType: Bullet, runChildUpdate: true });
                this.ammoPacks = this.physics.add.group();

                this.physics.add.overlap(this.bullets, this.enemies, this.hitEnemy, null, this);
                this.physics.add.overlap(this.player, this.enemies, this.playerHitByEnemy, null, this);
                this.physics.add.overlap(this.player, this.ammoPacks, this.collectAmmo, null, this);

                this.time.addEvent({ delay: 1500, callback: this.spawnEnemy, callbackScope: this, loop: true });
                this.time.addEvent({ delay: 5000, callback: this.spawnAmmoPack, callbackScope: this, loop: true });
                this.timerEvent = this.time.addEvent({ delay: 1000, callback: this.updateTimer, callbackScope: this, loop: true });

                this.bindHtmlControl('btn-up', 'up');
                this.bindHtmlControl('btn-down', 'down');
                this.bindHtmlControl('btn-left', 'left');
                this.bindHtmlControl('btn-right', 'right');
                
                const fireBtn = document.getElementById('btn-fire');
                const triggerFire = (e) => { e.preventDefault(); this.shootBullet(); };
                fireBtn.addEventListener('mousedown', triggerFire);
                fireBtn.addEventListener('touchstart', triggerFire);

                this.keys = this.input.keyboard.addKeys('W,A,S,D,UP,DOWN,LEFT,RIGHT');
                this.updateHud();
            }

            bindHtmlControl(id, prop) {
                const btn = document.getElementById(id);
                const start = (e) => { e.preventDefault(); this.inputs[prop] = true; };
                const end = (e) => { e.preventDefault(); this.inputs[prop] = false; };
                btn.addEventListener('mousedown', start); btn.addEventListener('mouseup', end);
                btn.addEventListener('touchstart', start); btn.addEventListener('touchend', end);
                btn.addEventListener('mouseleave', end);
            }

            update() {
                if (this.gameOver) return;
                this.handleMovement();
            }

            handleMovement() {
                this.player.setVelocity(0);
                let vx = 0, vy = 0;

                const up = this.inputs.up || this.keys.W.isDown || this.keys.UP.isDown;
                const down = this.inputs.down || this.keys.S.isDown || this.keys.DOWN.isDown;
                const left = this.inputs.left || this.keys.A.isDown || this.keys.LEFT.isDown;
                const right = this.inputs.right || this.keys.D.isDown || this.keys.RIGHT.isDown;

                if (left) vx = -this.playerSpeed;
                else if (right) vx = this.playerSpeed;
                if (up) vy = -this.playerSpeed;
                else if (down) vy = this.playerSpeed;

                this.player.setVelocity(vx, vy);

                // [修改點 3] 根據速度方向播放對應動畫
                if (vx !== 0 || vy !== 0) {
                    this.player.body.velocity.normalize().scale(this.playerSpeed);
                    
                    // 判斷要播放哪個方向的動畫 (ignoreIfPlaying: true)
                    if (vx > 0) {
                        this.player.anims.play('walk-right', true);
                        this.lastFacing = 0;
                    } else if (vx < 0) {
                        this.player.anims.play('walk-left', true);
                        this.lastFacing = 180;
                    } else if (vy > 0) {
                        this.player.anims.play('walk-down', true);
                        this.lastFacing = 90;
                    } else if (vy < 0) {
                        this.player.anims.play('walk-up', true);
                        this.lastFacing = -90;
                    }
                    
                } else {
                    // 沒移動時，停止動畫，停在最後一格
                    this.player.anims.stop();
                    
                    // (進階優化) 如果希望停下來時顯示該方向的「站立圖」(通常是第0格)
                    // 可以依據 lastFacing 來設定 Frame，例如：
                    // if (this.lastFacing === 90) this.player.setFrame(0); // Down
                    // else if (this.lastFacing === 180) this.player.setFrame(4); // Left
                    // else if (this.lastFacing === 0) this.player.setFrame(8); // Right
                    // else if (this.lastFacing === -90) this.player.setFrame(12); // Up
                }
            }

            // ... (shootBullet, hitEnemy, playerHitByEnemy, collectAmmo, spawnEnemy, spawnAmmoPack, updateTimer, updateHud 保持不變) ...
            shootBullet() {
                if (this.gameOver || this.playerAmmo <= 0) return;
                const bullet = this.bullets.get(this.player.x, this.player.y);
                if (bullet) {
                    this.playerAmmo--;
                    this.updateHud();
                    bullet.fire(this.player.x, this.player.y, this.lastFacing);
                }
            }
            hitEnemy(bullet, enemy) {
                bullet.destroy();
                const damage = Phaser.Math.Between(1, 2);
                enemy.takeDamage(damage);
                const txt = this.add.text(enemy.x, enemy.y - 20, damage, { fontSize: '16px', fill: '#fff' }).setOrigin(0.5);
                this.tweens.add({ targets: txt, y: enemy.y - 50, alpha: 0, duration: 500, onComplete: () => txt.destroy() });
                if (enemy.health <= 0) {
                    enemy.destroy();
                    this.playerScore += 10;
                    this.updateHud();
                }
            }
            playerHitByEnemy() {
                if (this.gameOver) return;
                this.gameOver = true;
                this.physics.pause();
                alert('遊戲結束！你被抓住了。');
                location.reload();
            }
            collectAmmo(player, pack) {
                pack.destroy();
                this.playerAmmo = Math.min(this.playerAmmo + 10, this.maxPlayerAmmo);
                this.updateHud();
            }
            spawnEnemy() {
                if (this.gameOver) return;
                const r = 500; const angle = Phaser.Math.Between(0, 360);
                const x = this.player.x + Math.cos(angle) * r;
                const y = this.player.y + Math.sin(angle) * r;
                if (x > 0 && x < 2000 && y > 0 && y < 2000) {
                    const enemy = this.enemies.get(x, y);
                    if (enemy) enemy.init(this.player, this.enemySpeed);
                }
            }
            spawnAmmoPack() {
                if (this.gameOver) return;
                this.ammoPacks.create(Phaser.Math.Between(100, 1900), Phaser.Math.Between(100, 1900), 'ammoPack');
            }
            updateTimer() {
                if (this.gameOver) return;
                this.gameTimer--;
                this.updateHud();
                if (this.gameTimer <= 0) {
                    this.gameOver = true; this.physics.pause();
                    alert('時間到！生存成功！\n分數: ' + this.playerScore); location.reload();
                }
            }
            updateHud() {
                document.getElementById('hud-ammo').innerText = `Ammo: ${this.playerAmmo}/${this.maxPlayerAmmo}`;
                document.getElementById('hud-score').innerText = `Score: ${this.playerScore}`;
                document.getElementById('hud-time').innerText = `Time: ${this.gameTimer}`;
            }
        }

        // ... (Enemy 和 Bullet 類別保持不變) ...
        class Enemy extends Phaser.Physics.Arcade.Sprite {
            constructor(scene, x, y) { super(scene, x, y, 'enemy'); }
            init(player, speed) {
                this.player = player; this.speed = speed; this.health = 2;
                this.setActive(true).setVisible(true); this.body.reset(this.x, this.y);
            }
            takeDamage(amount) {
                this.health -= amount; this.setTint(0xff8888);
                this.scene.time.delayedCall(100, () => this.clearTint());
            }
            update() {
                if (!this.active || !this.player) return;
                this.scene.physics.moveToObject(this, this.player, this.speed);
            }
        }

        class Bullet extends Phaser.Physics.Arcade.Sprite {
            constructor(scene, x, y) { super(scene, x, y, 'bullet'); }
            fire(x, y, angle) {
                this.body.reset(x, y); this.setActive(true).setVisible(true); this.setAngle(angle);
                this.scene.physics.velocityFromAngle(angle, 400, this.body.velocity);
                this.scene.time.delayedCall(2000, () => this.destroy());
            }
        }

        const config = {
            type: Phaser.AUTO,
            scale: { mode: Phaser.Scale.RESIZE, parent: 'game-container', autoCenter: Phaser.Scale.CENTER_BOTH },
            physics: { default: 'arcade', arcade: { debug: false } },
            scene: MyGame
        };

        const game = new Phaser.Game(config);
    </script>
</body>
</html>
