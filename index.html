<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ç¾…è³“æ¼¢æˆ°è¨˜ - Phase 9 (Animation)</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
    <style>
        body { 
            margin: 0; padding: 0; background-color: #2d2d2d; overflow: hidden; 
            font-family: 'Segoe UI', sans-serif; 
            user-select: none; -webkit-user-select: none; 
            touch-action: none;
        }
        #game-container { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; }
        
        #ui-layer {
            position: absolute; top: 10px; left: 10px; right: 10px; color: white; pointer-events: none;
            text-shadow: 1px 1px 2px black;
            display: flex; flex-direction: column; gap: 5px;
            z-index: 10;
        }
        
        .hud-box {
            background-color: rgba(0, 0, 0, 0.6); padding: 10px; border-radius: 8px;
            pointer-events: auto;
        }

        #game-over-screen {
            display: none; position: absolute; top: 0; left: 0; width: 100vw; height: 100vh;
            background: rgba(0,0,0,0.85); color: white; z-index: 20;
            flex-direction: column; justify-content: center; align-items: center; text-align: center;
        }
        #game-over-title { font-size: 3em; margin-bottom: 20px; font-weight: bold; }
        button.restart-btn { margin-top: 30px; padding: 15px 40px; font-size: 1.5em; cursor: pointer; background: gold; border: none; border-radius: 8px; font-weight: bold; }
        
        #mobile-controls {
            position: absolute; bottom: 20px; right: 20px; z-index: 15; pointer-events: auto;
        }
        #mode-btn {
            width: 80px; height: 80px; border-radius: 50%; border: 4px solid white;
            background-color: rgba(0, 255, 0, 0.5); color: white; font-weight: bold; font-size: 14px;
            display: flex; justify-content: center; align-items: center; text-align: center;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5); cursor: pointer; user-select: none;
            transition: transform 0.1s;
        }
        #mode-btn:active { transform: scale(0.95); }

        .stat-row { display: flex; justify-content: space-between; margin-bottom: 2px; font-size: 14px; }
        .bar-container { width: 100%; background: #444; height: 8px; border-radius: 4px; margin-top: 2px; overflow: hidden; }
        .bar-fill { height: 100%; background: lime; width: 0%; transition: width 0.5s; }
    </style>
</head>
<body>

<div id="ui-layer">
    <div class="hud-box">
        <div class="stat-row">
            <span>â³ <span id="time-display" style="color: cyan;">05:00</span></span>
            <span>ğŸ’° <span id="gold-display" style="color: gold;">0</span></span>
        </div>
        <div>
            åè²: <span id="rep-display">0</span> / 3000
            <div class="bar-container"><div id="rep-bar" class="bar-fill"></div></div>
        </div>
        <div style="margin-top:5px; font-size:12px; color:#aaa;">
            éƒ¨éšŠ: <span id="squad-count">0</span> | æ•µè»: <span id="enemy-count">0</span>
        </div>
    </div>
</div>

<div id="mobile-controls">
    <div id="mode-btn" onclick="toggleMode()">ğŸ›¡ï¸<br>è·Ÿéš¨</div>
</div>

<div id="game-over-screen">
    <div id="game-over-title">GAME OVER</div>
    <div id="game-over-desc" style="padding: 0 20px;"></div>
    <button class="restart-btn" onclick="location.reload()">å†ç©ä¸€æ¬¡</button>
</div>

<div id="game-container"></div>

<script>
// --- å…¨åŸŸè¨­å®š ---
const GAME_DURATION = 300; 
const TARGET_REP = 3000;

let game, player, director;
let gold = 300; 
let reputation = 0;
let isAutoAttackMode = false;
let gameTimeLeft = GAME_DURATION;
let isGameOver = false;

let joyStick = { active: false, startX: 0, startY: 0, currX: 0, currY: 0, vec: new Phaser.Math.Vector2(0,0) };

let squad, enemies, wildLife, obstacles, projectiles;
let villages = [];
let uiTexts = {}; 
let cursors, wasd, keys;

// --- UI æ“ä½œ ---
function toggleMode() {
    isAutoAttackMode = !isAutoAttackMode;
    const btn = document.getElementById('mode-btn');
    if (isAutoAttackMode) {
        btn.innerHTML = "âš”ï¸<br>æ”»æ“Š";
        btn.style.backgroundColor = "rgba(255, 0, 0, 0.6)";
    } else {
        btn.innerHTML = "ğŸ›¡ï¸<br>è·Ÿéš¨";
        btn.style.backgroundColor = "rgba(0, 255, 0, 0.5)";
    }
}

function updateGold(amount) {
    gold += amount;
    uiTexts.gold.innerText = gold;
}

function updateRep(amount) {
    reputation += amount;
    if (reputation < 0) reputation = 0;
    uiTexts.rep.innerText = Math.floor(reputation);
    let pct = Math.min((reputation / TARGET_REP) * 100, 100);
    uiTexts.repBar.style.width = pct + "%";
}

function showDamageText(scene, x, y, amount, color = '#fff') {
    let text = scene.add.text(x, y - 20, amount, {
        fontSize: '16px', color: color, stroke: '#000', strokeThickness: 3, fontWeight: 'bold'
    }).setOrigin(0.5).setDepth(20);
    scene.tweens.add({ targets: text, y: y - 50, alpha: 0, duration: 800, onComplete: () => text.destroy() });
}

function showToast(scene, msg, color) {
    let text = scene.add.text(player.x, player.y - 150, msg, {
        fontSize: '20px', color: color, stroke: '#000', strokeThickness: 4, backgroundColor: 'rgba(0,0,0,0.6)', padding: {x:10, y:5}
    }).setOrigin(0.5).setDepth(100);
    scene.tweens.add({ targets: text, y: player.y - 200, alpha: 0, duration: 3000, onComplete: () => text.destroy() });
}

function checkGameOver() {
    if (isGameOver) return;
    if (gameTimeLeft <= 0) {
        if (reputation >= TARGET_REP) endGame(true, "å‚³å¥‡èª•ç”Ÿï¼<br>ä½ æˆåŠŸæŠµæŠ—äº†æš´æ”¿ï¼Œä¸¦å»ºç«‹äº†æ–°çš„ç§©åºã€‚");
        else endGame(false, "èµ·ç¾©å¤±æ•—ã€‚<br>éš¨è‘—ç…å¿ƒç‹æ­¸åœ‹ï¼Œä½ çš„åå­—è¢«éºå¿˜åœ¨æ­·å²ä¸­ã€‚");
    }
}

function endGame(victory, message) {
    isGameOver = true;
    game.scene.pause("default");
    const screen = document.getElementById('game-over-screen');
    const title = document.getElementById('game-over-title');
    const desc = document.getElementById('game-over-desc');
    screen.style.display = 'flex';
    title.innerText = victory ? "VICTORY!" : "DEFEAT";
    title.style.color = victory ? "gold" : "red";
    desc.innerHTML = message;
}

// --- å–®ä½é¡åˆ¥ ---
class Unit extends Phaser.GameObjects.Rectangle {
    constructor(scene, x, y, width, height, color, hp, maxHp) {
        super(scene, x, y, width, height, color);
        scene.add.existing(this);
        scene.physics.add.existing(this);
        this.hp = hp;
        this.maxHp = maxHp || hp;
        this.isDead = false;
        this.lastAttackTime = 0;
        this.hpBarBg = scene.add.rectangle(x, y - height, width, 4, 0x000000).setDepth(1);
        this.hpBar = scene.add.rectangle(x, y - height, width, 4, 0x00ff00).setDepth(1);
    }
    preUpdate() {
        if (this.isDead) return;
        this.hpBarBg.setPosition(this.x, this.y - this.height/2 - 5);
        this.hpBar.setPosition(this.x, this.y - this.height/2 - 5);
    }
    takeDamage(amount) {
        if (this.isDead) return;
        this.scene.tweens.add({ targets: this, alpha: 0.2, duration: 50, yoyo: true, repeat: 1 });
        this.hp -= amount;
        showDamageText(this.scene, this.x, this.y, amount);
        const pct = Math.max(0, this.hp / this.maxHp);
        this.hpBar.width = this.width * pct;
        if (pct < 0.3) this.hpBar.fillColor = 0xff0000;
        else if (pct < 0.6) this.hpBar.fillColor = 0xffff00;
        if (this.hp <= 0) this.die();
    }
    die() {
        this.isDead = true;
        this.hpBar.destroy(); this.hpBarBg.destroy();
        const particles = this.scene.add.particles(this.x, this.y, 'pixel', { speed: 100, scale: { start: 1, end: 0 }, lifespan: 500, blendMode: 'ADD', tint: this.fillColor });
        this.scene.time.delayedCall(500, () => particles.destroy());
        this.destroy();
    }
}

class Projectile extends Phaser.GameObjects.Rectangle {
    constructor(scene, x, y, target, damage, isEnemy, speed, lifeTime, color) {
        super(scene, x, y, 10, 4, color || (isEnemy ? 0xff4444 : 0xffff00));
        scene.add.existing(this);
        scene.physics.add.existing(this);
        this.damage = damage;
        this.isEnemy = isEnemy;
        this.bornTime = Date.now();
        this.lifeTime = lifeTime || 1000;
        const angle = Phaser.Math.Angle.Between(x, y, target.x, target.y);
        this.rotation = angle;
        scene.physics.velocityFromRotation(angle, speed || 400, this.body.velocity);
    }
    update() { if (Date.now() - this.bornTime > this.lifeTime) this.destroy(); }
}

class MeleeSlash extends Projectile {
    constructor(scene, x, y, target, damage, isEnemy) {
        super(scene, x, y, target, damage, isEnemy, 600, 150, 0xffffff);
        this.width = 16; this.height = 16; 
        scene.tweens.add({ targets: this, scaleX: 1.5, scaleY: 1.5, alpha: 0, duration: 150 });
    }
}

// --- è‹±é›„ ---
class Hero extends Phaser.Physics.Arcade.Sprite {
    constructor(scene, x, y) {
        // [ä¿®æ”¹] é€™è£¡ä½¿ç”¨ 'player' keyï¼Œé€™å€‹ key åœ¨ preload ä¸­è¢«è¼‰å…¥ç‚º spritesheet
        super(scene, x, y, 'player', 0); // 0 æ˜¯é è¨­ frame
        
        scene.add.existing(this);
        scene.physics.add.existing(this);
        
        this.setScale(1.0); // å‡è¨­åœ–æœ‰é»å°ï¼Œå¯èƒ½ä¸éœ€è¦ç¸®å°äº†ï¼Œå…ˆé‚„åŸ
        
        this.body.setCollideWorldBounds(true);
        this.body.pushable = false;
        // [èª¿æ•´] ç¨å¾®èª¿æ•´ç¢°æ’æ¡†ï¼Œé¿å…é ­éƒ¨å¡ä½
        this.body.setSize(20, 20); 
        this.body.setOffset(6, 12); // èª¿æ•´ offset è®“ç¢°æ’æ¡†åœ¨è…³éƒ¨
        
        this.hp = 300; this.maxHp = 300; this.isDead = false;
        this.lastAttackTime = 0;
        this.speed = 220;
        this.detectRange = 100; this.attackCooldown = 500;
        
        this.hpBarBg = scene.add.rectangle(x, y - 30, 40, 4, 0x000000).setDepth(1);
        this.hpBar = scene.add.rectangle(x, y - 30, 40, 4, 0x00ff00).setDepth(1);
        
        // æ’­æ”¾åˆå§‹å‹•ç•« (ä¾‹å¦‚å‘ä¸‹)
        this.play('walk-down', true);
        this.anims.stop(); // åˆå§‹éœæ­¢
    }
    
    preUpdate(time, delta) {
        super.preUpdate(time, delta);
        if (this.isDead) return;
        this.hpBarBg.setPosition(this.x, this.y - 30);
        this.hpBar.setPosition(this.x, this.y - 30);
    }

    move() {
        this.body.setVelocity(0);
        let vx = 0, vy = 0;

        if (cursors.left.isDown || wasd.left.isDown) vx = -1;
        else if (cursors.right.isDown || wasd.right.isDown) vx = 1;
        
        if (cursors.up.isDown || wasd.up.isDown) vy = -1;
        else if (cursors.down.isDown || wasd.down.isDown) vy = 1;

        if (joyStick.active) {
            vx = joyStick.vec.x;
            vy = joyStick.vec.y;
        }

        if (vx !== 0 || vy !== 0) {
            let v = new Phaser.Math.Vector2(vx, vy).normalize().scale(this.speed);
            this.body.setVelocity(v.x, v.y);
            
            // [æ–°å¢] å‹•ç•«é‚è¼¯
            // å„ªå…ˆåˆ¤æ–· Y è»¸ (ä¸Šä¸‹)ï¼Œå†åˆ¤æ–· X è»¸ (å·¦å³)
            if (Math.abs(vy) >= Math.abs(vx)) {
                if (vy > 0) this.play('walk-down', true);
                else this.play('walk-up', true);
            } else {
                if (vx > 0) this.play('walk-right', true);
                else this.play('walk-left', true);
            }
        } else {
            // åœæ­¢ç§»å‹•æ™‚ï¼Œåœæ­¢å‹•ç•«ä¸¦åœåœ¨ç¬¬ä¸€å¹€
            this.anims.stop();
        }
    }
    
    update() {
        if(this.isDead) return;
        this.move();
        if (Date.now() - this.lastAttackTime > this.attackCooldown) {
            let target = this.findTarget(enemies, this.detectRange);
            if (!target) target = this.findTarget(wildLife, this.detectRange);
            if (target) {
                projectiles.add(new MeleeSlash(this.scene, this.x, this.y, target, 25, false));
                this.lastAttackTime = Date.now();
            }
        }
    }
    
    findTarget(group, range) {
        let target = null; let minDist = range;
        group.children.iterate(u => { 
            if (u && !u.isDead && u.body) { 
                let d = Phaser.Math.Distance.Between(this.x, this.y, u.x, u.y); 
                if (d < minDist) { minDist = d; target = u; } 
            } 
        });
        return target;
    }
    
    takeDamage(amount) {
        if (this.isDead) return;
        this.scene.tweens.add({ targets: this, alpha: 0.2, duration: 50, yoyo: true, repeat: 1 });
        this.hp -= amount;
        showDamageText(this.scene, this.x, this.y, amount);
        const pct = Math.max(0, this.hp / this.maxHp);
        this.hpBar.width = 40 * pct;
        if (pct < 0.3) this.hpBar.fillColor = 0xff0000;
        else if (pct < 0.6) this.hpBar.fillColor = 0xffff00;
        if (this.hp <= 0) this.die();
    }

    die() {
        this.isDead = true;
        this.hpBar.destroy(); this.hpBarBg.destroy();
        this.destroy();
        endGame(false, "ä½ æˆ°æ­»æ²™å ´ï¼Œé©å‘½ä¹‹ç«ç†„æ»…äº†ã€‚");
    }
}

// --- å£«å…µèˆ‡å¼“æ‰‹ ---
class Soldier extends Unit {
    constructor(scene, x, y) { super(scene, x, y, 20, 20, 0x33ccff, 60, 60); this.speed = 180; this.detectRange = 300; this.guardRange = 120; this.attackRange = 40; this.wanderOffset = new Phaser.Math.Vector2(Phaser.Math.Between(-50,50), Phaser.Math.Between(-50,50)); }
    update(player, isAutoMode) {
        if(this.isDead) return; this.preUpdate();
        if (!isAutoMode) { this.follow(player, false); return; }
        let target = this.findTarget(enemies, this.detectRange);
        if (!target && isAutoMode) target = this.findTarget(wildLife, this.detectRange);
        if (target) {
            let dist = Phaser.Math.Distance.Between(this.x, this.y, target.x, target.y);
            if (dist <= this.attackRange) { this.body.setVelocity(0); if (Date.now() - this.lastAttackTime > 800) { projectiles.add(new MeleeSlash(this.scene, this.x, this.y, target, 15, false)); this.lastAttackTime = Date.now(); } } 
            else { this.scene.physics.moveToObject(this, target, this.speed * 1.2); }
        } else { this.follow(player, isAutoMode); }
    }
    findTarget(group, range) { let target = null; let minDist = range; group.children.iterate(u => { if (u && !u.isDead && u.body) { let d = Phaser.Math.Distance.Between(this.x, this.y, u.x, u.y); if (d < minDist) { minDist = d; target = u; } } }); return target; }
    follow(player, isAutoMode) { let d = Phaser.Math.Distance.Between(this.x, this.y, player.x, player.y); if (d > 60) this.scene.physics.moveTo(this, player.x + this.wanderOffset.x, player.y + this.wanderOffset.y, this.speed); else this.body.setVelocity(0); }
}

class Archer extends Unit {
    constructor(scene, x, y) { super(scene, x, y, 16, 16, 0x00ffff, 30, 30); this.speed = 160; this.detectRange = 350; this.attackRange = 180; this.wanderOffset = new Phaser.Math.Vector2(Phaser.Math.Between(-50,50), Phaser.Math.Between(-50,50)); }
    update(player, isAutoMode) {
        if(this.isDead) return; this.preUpdate();
        if (!isAutoMode) { this.follow(player, false); return; }
        let target = this.findTarget(enemies, this.detectRange);
        if (!target && isAutoMode) target = this.findTarget(wildLife, this.detectRange);
        if (target) {
            let d = Phaser.Math.Distance.Between(this.x, this.y, target.x, target.y);
            if (d > this.attackRange) { this.scene.physics.moveToObject(this, target, this.speed); } 
            else { this.body.setVelocity(0); if (Date.now() - this.lastAttackTime > 1200) { projectiles.add(new Projectile(this.scene, this.x, this.y, target, 15, false)); this.lastAttackTime = Date.now(); } }
        } else { this.follow(player, isAutoMode); }
    }
    findTarget(group, range) { let target = null; let minDist = range; group.children.iterate(u => { if (u && !u.isDead && u.body) { let d = Phaser.Math.Distance.Between(this.x, this.y, u.x, u.y); if (d < minDist) { minDist = d; target = u; } } }); return target; }
    follow(player, isAutoMode) { let d = Phaser.Math.Distance.Between(this.x, this.y, player.x, player.y); if (d > 70) this.scene.physics.moveTo(this, player.x + this.wanderOffset.x, player.y + this.wanderOffset.y, this.speed); else this.body.setVelocity(0); }
}

// --- æ•µäºº ---
class EnemyUnit extends Unit {
    constructor(scene, x, y, color, hp, speed, target) { super(scene, x, y, 20, 20, color, hp, hp); this.moveTarget = target; this.speed = speed; this.attackRange = 40; }
    findAggroTarget() { let target = null; let minDist = 200; let d = Phaser.Math.Distance.Between(this.x, this.y, player.x, player.y); if (d < minDist) { minDist = d; target = player; } squad.children.iterate(s => { if(s && !s.isDead) { let sd = Phaser.Math.Distance.Between(this.x, this.y, s.x, s.y); if (sd < minDist) { minDist = sd; target = s; } } }); return target; }
}
class EnemySoldier extends EnemyUnit {
    constructor(scene, x, y, target) { super(scene, x, y, 0xff4444, 60, 130, target); }
    update() {
        if(this.isDead) return; this.preUpdate();
        let combatTarget = this.findAggroTarget(); let finalTarget = combatTarget || this.moveTarget;
        if (this.moveTarget instanceof Village) { let distToVillage = Phaser.Math.Distance.Between(this.x, this.y, this.moveTarget.x, this.moveTarget.y); if (distToVillage < this.moveTarget.siegeRadius) { if (!combatTarget) { this.body.setVelocity(0); return; } } }
        if (finalTarget && !finalTarget.isDead) { let dist = Phaser.Math.Distance.Between(this.x, this.y, finalTarget.x, finalTarget.y); if (dist <= this.attackRange) { this.body.setVelocity(0); if (Date.now() - this.lastAttackTime > 1000) { projectiles.add(new MeleeSlash(this.scene, this.x, this.y, finalTarget, 10, true)); this.lastAttackTime = Date.now(); } } else this.scene.physics.moveToObject(this, finalTarget, this.speed); }
    }
}
class EnemyArcher extends EnemyUnit {
    constructor(scene, x, y, target) { super(scene, x, y, 0xff8888, 40, 110, target); this.attackRange = 180; }
    update() {
        if(this.isDead) return; this.preUpdate();
        let combatTarget = this.findAggroTarget(); let finalTarget = combatTarget || this.moveTarget;
        if (!combatTarget && this.moveTarget instanceof Village) { let distToVillage = Phaser.Math.Distance.Between(this.x, this.y, this.moveTarget.x, this.moveTarget.y); if (distToVillage < this.moveTarget.siegeRadius) { this.body.setVelocity(0); return; } }
        if (finalTarget && !finalTarget.isDead) { let dist = Phaser.Math.Distance.Between(this.x, this.y, finalTarget.x, finalTarget.y); if (dist > this.attackRange) { this.scene.physics.moveToObject(this, finalTarget, this.speed); } else { this.body.setVelocity(0); if (Date.now() - this.lastAttackTime > 1500) { projectiles.add(new Projectile(this.scene, this.x, this.y, finalTarget, 10, true)); this.lastAttackTime = Date.now(); } } }
    }
}
class Carriage extends EnemyUnit {
    constructor(scene, startX, startY, endX, endY) { super(scene, startX, startY, 0xffd700, 300, 30, null); this.width = 40; this.height = 60; this.targetPos = new Phaser.Math.Vector2(endX, endY); this.body.setCollideWorldBounds(true); this.body.setImmovable(true); this.scene.physics.moveTo(this, endX, endY, this.speed); this.hpBarBg.destroy(); this.hpBar.destroy(); this.hpBarBg = scene.add.rectangle(this.x, this.y, 40, 4, 0x000000).setDepth(1); this.hpBar = scene.add.rectangle(this.x, this.y, 40, 4, 0x00ff00).setDepth(1); }
    die() { updateGold(600); updateRep(150); showToast(this.scene, "æ¶å¾— $600 + 150 Rep!", "gold"); super.die(); }
}
class Deer extends Unit {
    constructor(scene, x, y) { super(scene, x, y, 16, 16, 0xc2b280, 15); this.speed=40; this.timer=0; this.body.setCollideWorldBounds(true); }
    update() { if(this.isDead)return; this.preUpdate(); this.timer++; if(this.timer>100){ if(Math.random()>0.3) this.scene.physics.velocityFromAngle(Phaser.Math.Between(0,360),40,this.body.velocity); else this.body.setVelocity(0); this.timer=0; } }
    die() { updateGold(15); super.die(); }
}
class Wolf extends Unit {
    constructor(scene, x, y) { super(scene, x, y, 20, 20, 0x808080, 40); this.speed=100; this.body.setCollideWorldBounds(true); this.attackRange = 40; }
    update() { if(this.isDead)return; this.preUpdate(); let target = null; let minDist = 200; let d = Phaser.Math.Distance.Between(this.x, this.y, player.x, player.y); if (d < minDist) { minDist = d; target = player; } squad.children.iterate(s => { if(s && !s.isDead) { let sd = Phaser.Math.Distance.Between(this.x, this.y, s.x, s.y); if (sd < minDist) { minDist = sd; target = s; } } }); wildLife.children.iterate(w => { if(w instanceof Deer && !w.isDead) { let wd = Phaser.Math.Distance.Between(this.x, this.y, w.x, w.y); if (wd < minDist) { minDist = wd; target = w; } } }); if (target) { if (minDist <= this.attackRange) { this.body.setVelocity(0); if (Date.now() - this.lastAttackTime > 1000) { projectiles.add(new MeleeSlash(this.scene, this.x, this.y, target, 10, true)); this.lastAttackTime = Date.now(); } } else this.scene.physics.moveToObject(this, target, this.speed); } else { if (Math.random() < 0.02) this.scene.physics.velocityFromAngle(Phaser.Math.Between(0,360), 50, this.body.velocity); } }
    die() { updateGold(25); super.die(); }
}

// --- æ‘èŠç³»çµ± ---
class Village {
    constructor(scene, x, y, name) {
        this.scene = scene; this.x = x; this.y = y; this.name = name;
        this.level = 1; this.stock = 3; this.maxStock = 3; this.passiveTimer = 0; this.stockTimer = 0;
        this.zones = {
            upgrade: { x: x, y: y - 60, r: 30, color: 0xffff00, timer: 0, required: 3000, action: 'upgrade', label: 'å‡ç´š' },
            soldier: { x: x - 50, y: y + 50, r: 30, color: 0x0000ff, timer: 0, required: 1000, action: 'recruit_h', label: 'æ­¥å…µ' },
            archer: { x: x + 50, y: y + 50, r: 30, color: 0x00ffff, timer: 0, required: 1000, action: 'recruit_j', label: 'å¼“æ‰‹' }
        };
        this.siegeRadius = 90; this.integrity = 100; this.maxIntegrity = 100;
        this.siegeZone = scene.add.circle(x, y, this.siegeRadius, 0xff0000, 0.1); scene.physics.add.existing(this.siegeZone, true);
        this.siegeBar = scene.add.rectangle(x, y + 20, 60, 6, 0x00ff00).setOrigin(0.5);
        this.building = scene.add.rectangle(x, y, 60, 60, 0x8b4513); scene.physics.add.existing(this.building, true); obstacles.add(this.building);
        this.zoneGraphics = scene.add.graphics(); this.drawZones();
        this.nameText = scene.add.text(x, y - 40, name, {fontSize: '16px', fontWeight:'bold'}).setOrigin(0.5);
        this.levelText = scene.add.text(x, y - 25, "Lv.1", {fontSize: '14px', color:'#aaa'}).setOrigin(0.5);
    }
    
    drawZones() {
        this.zoneGraphics.clear();
        for (let key in this.zones) {
            let z = this.zones[key];
            this.zoneGraphics.lineStyle(2, z.color, 0.5); this.zoneGraphics.strokeCircle(z.x, z.y, z.r);
            if (z.timer > 0) { let pct = z.timer / z.required; this.zoneGraphics.fillStyle(0xffffff, 0.5); this.zoneGraphics.fillCircle(z.x, z.y, z.r * pct); }
        }
    }

    update(delta, enemies) {
        let playerDist = (gx, gy) => Phaser.Math.Distance.Between(player.x, player.y, gx, gy);
        let redraw = false;
        for (let key in this.zones) {
            let z = this.zones[key];
            if (playerDist(z.x, z.y) < z.r) {
                z.timer += delta; redraw = true;
                if (z.timer >= z.required) { this.executeAction(z.action); z.timer = 0; }
            } else { if (z.timer > 0) { z.timer = 0; redraw = true; } }
        }
        if (redraw) this.drawZones();

        let siegeCount = 0;
        enemies.children.iterate(e => { if (e && !e.isDead && Phaser.Math.Distance.Between(this.x, this.y, e.x, e.y) < this.siegeRadius) siegeCount++; });
        if (siegeCount > 0 && this.level > 1) {
            this.integrity -= siegeCount * (delta/1000) * 5; if (this.integrity <= 0) this.downgrade();
            this.siegeZone.fillColor = 0xff0000; this.siegeZone.fillAlpha = 0.3;
        } else {
            if (this.integrity < this.maxIntegrity) this.integrity += (delta/1000) * 2;
            this.siegeZone.fillColor = 0x000000; this.siegeZone.fillAlpha = 0.05;
        }
        this.siegeBar.width = 60 * (this.integrity / this.maxIntegrity);
        this.siegeBar.fillColor = (siegeCount > 0) ? 0xff0000 : 0x00ff00;

        if (this.level > 1) { this.passiveTimer += delta; if (this.passiveTimer > 5000) { let income = (this.level - 1) * 5; updateRep(income); this.passiveTimer = 0; } }
        if (this.stock < this.maxStock) { this.stockTimer += delta; if (this.stockTimer > 6000) { this.stock++; this.stockTimer = 0; } }
    }
    
    executeAction(action) {
        if (action === 'upgrade') this.upgrade();
        else if (action === 'recruit_h') { if(this.recruit('H')) squad.add(new Soldier(this.scene, player.x, player.y)); }
        else if (action === 'recruit_j') { if(this.recruit('J')) squad.add(new Archer(this.scene, player.x, player.y)); }
    }

    upgrade() {
        if (this.level >= 5) return false;
        let cost = this.level * 100;
        if (gold >= cost) {
            updateGold(-cost); this.level++; this.integrity = 100; this.maxStock = 2 + this.level; this.stock = this.maxStock;
            this.refreshVisuals(); showToast(this.scene, `${this.name} å‡ç´šè‡³ Lv.${this.level}!`, "cyan"); return true;
        } return false;
    }
    downgrade() { this.level = 1; this.integrity = 100; updateRep(-200); showToast(this.scene, `${this.name} è¢«æ”»é™·äº†ï¼`, "red"); this.refreshVisuals(); }
    recruit(type) { if (this.stock <= 0) return false; let cost = (type === 'H') ? 20 : 30; if (gold >= cost) { updateGold(-cost); this.stock--; showToast(this.scene, `æ‹›å‹ŸæˆåŠŸ (-$${cost})`, "lime"); return true; } return false; }
    refreshVisuals() { this.levelText.setText(`Lv.${this.level}`); let colors = [0x8b4513, 0xcd853f, 0xd2691e, 0xa0522d, 0x800000]; this.building.fillColor = colors[this.level-1] || 0x8b4513; }
}

class GameDirector {
    constructor(scene) { this.scene = scene; this.timers = { patrol: 0, caravan: 0 }; }
    update(delta) {
        if (isGameOver) return;
        this.timers.patrol += delta; this.timers.caravan += delta;
        let timeFactor = (300 - gameTimeLeft) / 60; let repFactor = reputation / 500;
        let difficulty = 1 + (timeFactor * 0.5) + (repFactor * 0.5);
        let patrolInterval = Math.max(10000, 40000 - (difficulty * 4000));
        if (this.timers.patrol > patrolInterval) { this.spawnPatrol(difficulty); this.timers.patrol = 0; }
        if (this.timers.caravan > 35000) { this.spawnCaravan(difficulty); this.timers.caravan = 0; }
    }
    spawnPatrol(difficulty) {
        let targets = [player]; villages.forEach(v => { if(v.level > 1) targets.push(v); });
        let target = targets[Phaser.Math.Between(0, targets.length-1)];
        let msg = (target === player) ? "å·¡é‚éšŠæ­£åœ¨æœæ•ä½ ï¼" : `å·¡é‚éšŠæ­£åœ¨å‰å¾€ ${target.name}ï¼`;
        showToast(this.scene, msg, "red");
        let count = Math.floor(2 + difficulty); let pos = getRandomEdgePos(this.scene, 100);
        for(let i=0; i<count; i++) {
            let px = pos.x + Phaser.Math.Between(-30,30); let py = pos.y + Phaser.Math.Between(-30,30);
            if (Math.random() < 0.3) enemies.add(new EnemyArcher(this.scene, px, py, target)); else enemies.add(new EnemySoldier(this.scene, px, py, target));
        }
    }
    spawnCaravan(difficulty) {
        let startX, startY, endX, endY; if (Math.random() > 0.5) { startX = 50; startY = Phaser.Math.Between(200, 1800); endX = 1950; endY = Phaser.Math.Between(200, 1800); } else { startX = Phaser.Math.Between(200, 1800); startY = 50; endX = Phaser.Math.Between(200, 1800); endY = 1950; }
        let carriage = new Carriage(this.scene, startX, startY, endX, endY); enemies.add(carriage);
        let guardCount = Math.floor(2 + difficulty);
        for(let i=0; i<guardCount; i++) {
            let px = startX + Phaser.Math.Between(-30,30); let py = startY + Phaser.Math.Between(-30,30);
            if (Math.random() < 0.3) enemies.add(new EnemyArcher(this.scene, px, py, player)); else enemies.add(new EnemySoldier(this.scene, px, py, player));
        }
    }
}

// --- Main Setup ---
const config = {
    type: Phaser.AUTO, width: window.innerWidth, height: window.innerHeight, parent: 'game-container',
    physics: { default: 'arcade', arcade: { gravity: { y: 0 }, debug: false } },
    scene: { preload: preload, create: create, update: update },
    backgroundColor: '#3b7d4f'
};

game = new Phaser.Game(config);

let joyGraphics;

function preload() {
    // è¼‰å…¥ spritesheetï¼Œè¨­å®š frameWidth/Height
    // å‡è¨­åŸå§‹åœ–æ˜¯åŒ…å« 4 è¡Œ 4 åˆ—çš„æ’åˆ— (ä¸€èˆ¬ RPG Maker æ ¼å¼)
    // å¦‚æœåœ–æ¯”è¼ƒç‰¹æ®Šï¼Œé€™è£¡çš„ 32, 32 å¯èƒ½éœ€è¦èª¿æ•´
    this.load.spritesheet('player', 'https://raw.githubusercontent.com/darkbearlab/gunFightSurvivor/refs/heads/main/player.png', {
        frameWidth: 32, 
        frameHeight: 32
    });
    
    const graphics = this.make.graphics({x: 0, y: 0, add: false});
    graphics.fillStyle(0xffffff, 1); graphics.fillRect(0, 0, 4, 4); graphics.generateTexture('pixel', 4, 4);
}

function getRandomEdgePos(scene, margin) {
    let x, y; if (Math.random() > 0.5) { x = Math.random() > 0.5 ? margin : 2000 - margin; y = Phaser.Math.Between(margin, 2000 - margin); } else { y = Math.random() > 0.5 ? margin : 2000 - margin; x = Phaser.Math.Between(margin, 2000 - margin); } return {x, y};
}

function create() {
    this.physics.world.setBounds(0, 0, 2000, 2000);
    this.add.grid(1000, 1000, 2000, 2000, 50, 50, 0x3b7d4f, 0, 0x000000, 0.1);

    obstacles = this.physics.add.staticGroup();
    squad = this.add.group({ runChildUpdate: false });
    enemies = this.add.group({ runChildUpdate: false });
    wildLife = this.add.group({ runChildUpdate: false });
    projectiles = this.add.group({ runChildUpdate: false });

    // å»ºç«‹å‹•ç•«
    // å‡è¨­é †åºæ˜¯ï¼šä¸‹(0-3), å·¦(4-7), å³(8-11), ä¸Š(12-15)
    // é€™æ˜¯éå¸¸æ¨™æº–çš„ RPG Maker æ ¼å¼ï¼Œå¦‚æœä½ çš„åœ–ä¸åŒï¼Œé †åºå¯èƒ½è¦æ”¹
    this.anims.create({
        key: 'walk-down',
        frames: this.anims.generateFrameNumbers('player', { start: 0, end: 3 }),
        frameRate: 8,
        repeat: -1
    });
    this.anims.create({
        key: 'walk-left',
        frames: this.anims.generateFrameNumbers('player', { start: 4, end: 7 }),
        frameRate: 8,
        repeat: -1
    });
    this.anims.create({
        key: 'walk-right',
        frames: this.anims.generateFrameNumbers('player', { start: 8, end: 11 }),
        frameRate: 8,
        repeat: -1
    });
    this.anims.create({
        key: 'walk-up',
        frames: this.anims.generateFrameNumbers('player', { start: 12, end: 15 }),
        frameRate: 8,
        repeat: -1
    });

    for (let i = 0; i < 80; i++) {
        let tx = Phaser.Math.Between(50, 1950); let ty = Phaser.Math.Between(50, 1950); let clear = true;
        [[400,400], [1000,1000], [1600,1600]].forEach(p => { if(Math.abs(tx-p[0])<150 && Math.abs(ty-p[1])<150) clear = false; });
        if (clear) { let tree = this.add.rectangle(tx, ty, 40, 40, 0x1e4726); this.physics.add.existing(tree, true); obstacles.add(tree); }
    }

    villages = [ new Village(this, 400, 400, "åŒ—å¢ƒæ‘"), new Village(this, 1000, 1000, "ä¸­å¤®å¸‚é›†"), new Village(this, 1600, 1600, "å—é¢¨é®") ];
    player = new Hero(this, 1000, 1100);
    this.cameras.main.startFollow(player, true, 0.09, 0.09); this.cameras.main.setZoom(1.0);
    
    for(let i=0; i<12; i++) { let p=getRandomEdgePos(this, 100); wildLife.add(new Deer(this, p.x, p.y)); }
    for(let i=0; i<5; i++) { let p=getRandomEdgePos(this, 100); wildLife.add(new Wolf(this, p.x, p.y)); }

    this.physics.add.collider(player, obstacles); this.physics.add.collider(player, enemies); this.physics.add.collider(player, wildLife);
    this.physics.add.collider(squad, obstacles); this.physics.add.collider(enemies, obstacles);
    this.physics.add.collider(wildLife, obstacles);
    this.physics.add.collider(squad, squad);
    this.physics.add.collider(squad, enemies);

    this.physics.add.overlap(projectiles, enemies, (p, e) => { if(!p.isEnemy) { e.takeDamage(p.damage); p.destroy(); } });
    this.physics.add.overlap(projectiles, wildLife, (p, e) => { if(!p.isEnemy) { e.takeDamage(p.damage); p.destroy(); } });
    this.physics.add.overlap(projectiles, squad, (p, s) => { if(p.isEnemy) { s.takeDamage(p.damage); p.destroy(); } });
    this.physics.add.overlap(projectiles, player, (p, h) => { if(p.isEnemy) { h.takeDamage(p.damage); p.destroy(); } });

    uiTexts.gold = document.getElementById('gold-display');
    uiTexts.squad = document.getElementById('squad-count');
    uiTexts.enemy = document.getElementById('enemy-count');
    uiTexts.rep = document.getElementById('rep-display');
    uiTexts.repBar = document.getElementById('rep-bar');
    updateGold(0); updateRep(0);

    cursors = this.input.keyboard.createCursorKeys();
    wasd = this.input.keyboard.addKeys({ up: 'W', down: 'S', left: 'A', right: 'D' });
    
    director = new GameDirector(this);
    
    this.time.addEvent({ delay: 1000, callback: () => {
        if (!isGameOver) {
            gameTimeLeft--;
            let m = Math.floor(gameTimeLeft/60); let s = gameTimeLeft%60;
            document.getElementById('time-display').innerText = `${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;
            checkGameOver();
        }
    }, loop: true });
    
    // æ–æ¡¿UI
    joyGraphics = this.add.graphics().setScrollFactor(0).setDepth(999);
    
    this.input.on('pointerdown', (pointer) => {
        if (pointer.y > window.innerHeight - 100 && pointer.x > window.innerWidth - 100) return; 
        joyStick.active = true;
        joyStick.startX = pointer.x; joyStick.startY = pointer.y;
        joyStick.currX = pointer.x; joyStick.currY = pointer.y;
        joyStick.vec.set(0, 0);
    });

    this.input.on('pointermove', (pointer) => {
        if (joyStick.active) {
            joyStick.currX = pointer.x; joyStick.currY = pointer.y;
            let dx = pointer.x - joyStick.startX; let dy = pointer.y - joyStick.startY;
            let dist = Math.sqrt(dx*dx + dy*dy); let maxDist = 50;
            if (dist > maxDist) { let ratio = maxDist / dist; joyStick.currX = joyStick.startX + dx * ratio; joyStick.currY = joyStick.startY + dy * ratio; }
            if (dist > 5) joyStick.vec.set(dx, dy).normalize(); else joyStick.vec.set(0, 0);
        }
    });

    this.input.on('pointerup', () => { joyStick.active = false; joyStick.vec.set(0, 0); joyGraphics.clear(); });
}

function update(time, delta) {
    if (isGameOver) return;
    
    if (joyStick.active) {
        joyGraphics.clear();
        joyGraphics.lineStyle(2, 0xffffff, 0.5); joyGraphics.strokeCircle(joyStick.startX, joyStick.startY, 50);
        joyGraphics.fillStyle(0xffffff, 0.8); joyGraphics.fillCircle(joyStick.currX, joyStick.currY, 20);
    } else joyGraphics.clear();

    player.update();
    director.update(delta);
    
    villages.forEach(v => v.update(delta, enemies));
    
    squad.children.iterate(u => u && u.update(player, isAutoAttackMode));
    enemies.children.iterate(u => u && u.update && u.update());
    wildLife.children.iterate(u => u && u.update && u.update());
    projectiles.children.iterate(p => p && p.update());

    uiTexts.squad.innerText = squad.countActive(true);
    uiTexts.enemy.innerText = enemies.countActive(true);
}

window.addEventListener('resize', () => game.scale.resize(window.innerWidth, window.innerHeight));
</script>

</body>
</html>
