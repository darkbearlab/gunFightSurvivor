<!DOCTYPE html>
<html>
<head>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser-arcade-physics.min.js"></script>
    <style> body { margin: 0; background: #000; touch-action: none; overflow: hidden; } </style>
</head>
<body>
    <script>
        class MyGame extends Phaser.Scene {
            constructor() {
                super('MyGame');
                this.score = 0;
            }

            preload() {
                this.createTex('p', 24, 24, 0x00ff00);
                this.createTex('e1', 24, 24, 0xff0000);
                this.createTex('e2', 24, 24, 0xff00ff);
                this.createTex('e3', 24, 24, 0xffa500);
                this.createTex('b', 8, 8, 0xffff00);
                this.createTex('eb', 8, 8, 0xffffff);
                this.createTex('cov', 1, 1, 0x666666);
            }

            createTex(k, w, h, c) {
                const g = this.make.graphics({ x: 0, y: 0, add: false });
                g.fillStyle(c, 1); g.fillRect(0, 0, w, h);
                g.generateTexture(k, w, h);
            }

            create() {
                this.physics.world.setBounds(0, 0, 2000, 2000);
                
                // 1. 建立群組 (先建立，確保成員能引用)
                this.bullets = this.physics.add.group();
                this.enemyBullets = this.physics.add.group();
                this.enemies = this.physics.add.group({ classType: Enemy, runChildUpdate: true });
                this.covers = this.physics.add.staticGroup();

                // 2. 玩家與攝影機
                this.player = this.physics.add.sprite(1000, 1000, 'p').setDepth(5);
                this.cameras.main.startFollow(this.player, true, 0.1, 0.1);
                this.cameras.main.setBounds(0, 0, 2000, 2000);

                // 3. 生成掩體
                for(let i=0; i<20; i++) {
                    let x = Phaser.Math.Between(100, 1900), y = Phaser.Math.Between(100, 1900);
                    if(Phaser.Math.Distance.Between(x, y, 1000, 1000) < 150) continue;
                    let c = this.covers.create(x, y, 'cov');
                    c.setDisplaySize(Phaser.Math.Between(40, 100), Phaser.Math.Between(40, 100)).refreshBody();
                    c.setData('hp', 3);
                }

                // 4. 碰撞邏輯 (TK 友傷就在這裡)
                this.physics.add.collider(this.player, this.covers);
                this.physics.add.collider(this.enemies, this.covers);
                this.physics.add.collider(this.enemies, this.enemies);
                
                // 擊中掩體
                const hitCov = (b, c) => { b.destroy(); let h = c.getData('hp')-1; c.setData('hp', h); c.setAlpha(h/3); if(h<=0) c.destroy(); };
                this.physics.add.overlap(this.bullets, this.covers, hitCov);
                this.physics.add.overlap(this.enemyBullets, this.covers, hitCov);

                // 玩家子彈打敵人
                this.physics.add.overlap(this.bullets, this.enemies, (b, e) => { b.destroy(); e.takeDamage(1); });
                
                // 敵人子彈打玩家 (一發死)
                this.physics.add.overlap(this.enemyBullets, this.player, () => this.gameOver('你被擊中了！'));
                this.physics.add.overlap(this.enemies, this.player, () => this.gameOver('你被撞到了！'));

                // 敵人子彈打敵人 (TK)
                this.physics.add.overlap(this.enemyBullets, this.enemies, (b, e) => { b.destroy(); e.takeDamage(1); });

                // 5. 虛擬搖桿與視線
                this.input.addPointer(1);
                this.joyL = { x: 120, y: 480, active: false, ptr: null };
                this.joyR = { x: 680, y: 480, active: false, ptr: null, ang: 0 };
                
                this.uiG = this.add.graphics().setScrollFactor(0).setDepth(10);
                this.laserG = this.add.graphics().setDepth(1);

                this.time.addEvent({ delay: 2000, callback: this.spawnEnemy, callbackScope: this, loop: true });
            }

            gameOver(msg) {
                alert(msg + "\n分數: " + this.score);
                location.reload();
            }

            spawnEnemy() {
                const ang = Math.random() * Math.PI * 2;
                const x = this.player.x + Math.cos(ang) * 600;
                const y = this.player.y + Math.sin(ang) * 600;
                const type = Phaser.Math.Between(1, 3);
                const enemy = this.enemies.get(x, y, 'e' + type);
                if (enemy) enemy.setup(type);
            }

            update() {
                this.handleJoysticks();
                this.drawUI();
            }

            handleJoysticks() {
                this.player.setVelocity(0);
                let speed = 200;

                [this.input.pointer1, this.input.pointer2, this.input.mousePointer].forEach(p => {
                    if (p.isDown) {
                        if (Phaser.Math.Distance.Between(p.x, p.y, 120, 480) < 100 && (!this.joyR.ptr || this.joyR.ptr !== p)) {
                            this.joyL.active = true; this.joyL.ptr = p;
                        } else if (Phaser.Math.Distance.Between(p.x, p.y, 680, 480) < 100 && (!this.joyL.ptr || this.joyL.ptr !== p)) {
                            this.joyR.active = true; this.joyR.ptr = p;
                        }
                    }
                });

                if (this.joyL.ptr && !this.joyL.ptr.isDown) { this.joyL.active = false; this.joyL.ptr = null; }
                if (this.joyR.ptr && !this.joyR.ptr.isDown) {
                    if (this.joyR.active) this.fireBullet();
                    this.joyR.active = false; this.joyR.ptr = null;
                }

                if (this.joyL.active) {
                    let ang = Phaser.Math.Angle.Between(120, 480, this.joyL.ptr.x, this.joyL.ptr.y);
                    if (this.joyR.active) speed *= 0.5; // 瞄準時減速
                    this.player.setVelocity(Math.cos(ang)*speed, Math.sin(ang)*speed);
                }

                this.laserG.clear();
                if (this.joyR.active) {
                    this.joyR.ang = Phaser.Math.Angle.Between(680, 480, this.joyR.ptr.x, this.joyR.ptr.y);
                    this.player.rotation = this.joyR.ang;
                    this.laserG.lineStyle(1, 0x00ff00, 0.3);
                    this.laserG.lineBetween(this.player.x, this.player.y, this.player.x + Math.cos(this.joyR.ang)*800, this.player.y + Math.sin(this.joyR.ang)*800);
                }
            }

            fireBullet() {
                const b = this.bullets.get(this.player.x, this.player.y, 'b');
                if (b) {
                    b.setActive(true).setVisible(true);
                    this.physics.velocityFromRotation(this.joyR.ang, 600, b.body.velocity);
                }
            }

            drawUI() {
                this.uiG.clear();
                this.uiG.lineStyle(2, 0xffffff, 0.3);
                this.uiG.strokeCircle(120, 480, 60);
                this.uiG.strokeCircle(680, 480, 60);
            }
        }

        // 敵人 Class：修正 Scope 問題
        class Enemy extends Phaser.Physics.Arcade.Sprite {
            setup(type) {
                this.type = type;
                this.hp = 2;
                this.lastFired = 0;
                this.setActive(true).setVisible(true);
                this.setTint(type === 1 ? 0xff0000 : (type === 2 ? 0xff00ff : 0xffa500));
            }
            takeDamage(n) {
                this.hp -= n; if(this.hp <= 0) { this.scene.score += 10; this.destroy(); }
            }
            update(time) {
                if (!this.active || !this.body) return;
                const dist = Phaser.Math.Distance.Between(this.x, this.y, this.scene.player.x, this.scene.player.y);
                
                // 追逐邏輯
                if (dist > 350) this.scene.physics.moveToObject(this, this.scene.player, 80);
                else if (dist < 200) this.scene.physics.moveToObject(this, this.scene.player, -60);
                else this.setVelocity(0);

                // 射擊頻率 (點射 1.5s, 連發/霰彈 2s)
                const rate = this.type === 1 ? 1500 : 2000;
                if (time > this.lastFired + rate && dist < 500) {
                    this.fire();
                    this.lastFired = time;
                }
            }
            fire() {
                const ang = Phaser.Math.Angle.Between(this.x, this.y, this.scene.player.x, this.scene.player.y);
                const shoot = (a) => {
                    if (!this.scene) return; // 確保場景還在
                    const b = this.scene.enemyBullets.get(this.x, this.y, 'eb');
                    if (b) {
                        b.setActive(true).setVisible(true);
                        this.scene.physics.velocityFromRotation(a, 350, b.body.velocity);
                    }
                };

                if (this.type === 1) shoot(ang);
                else if (this.type === 2) {
                    for(let i=0; i<3; i++) this.scene.time.delayedCall(i*150, () => shoot(ang));
                }
                else if (this.type === 3) {
                    for(let i=-1; i<=1; i++) shoot(ang + i*0.25);
                }
            }
        }

        new Phaser.Game({
            type: Phaser.AUTO, width: 800, height: 600,
            physics: { default: 'arcade', arcade: { gravity: { y: 0 } } },
            scene: MyGame,
            input: { activePointers: 3 }
        });
    </script>
</body>
</html>
