<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser-arcade-physics.min.js"></script>
    <style>
        body { margin: 0; background: #222; font-family: 'Arial', sans-serif; overflow: hidden; touch-action: none; user-select: none; -webkit-user-select: none; }
        #game-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; pointer-events: none; }
        .btn {
            position: absolute; background: rgba(255, 255, 255, 0.2); border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 10px; pointer-events: auto; touch-action: none;
            display: flex; align-items: center; justify-content: center;
            color: white; font-weight: bold; font-size: 24px; user-select: none;
        }
        .btn:active { background: rgba(255, 255, 255, 0.5); }
        #dpad { position: absolute; bottom: 20px; left: 20px; width: 150px; height: 150px; }
        #btn-up { top: 0; left: 50px; width: 50px; height: 50px; }
        #btn-down { bottom: 0; left: 50px; width: 50px; height: 50px; }
        #btn-left { top: 50px; left: 0; width: 50px; height: 50px; }
        #btn-right { top: 50px; right: 0; width: 50px; height: 50px; }
        #btn-fire { 
            position: absolute; bottom: 40px; right: 40px; 
            width: 80px; height: 80px; border-radius: 50%; 
            background: rgba(255, 0, 0, 0.3); border-color: rgba(255, 0, 0, 0.6);
        }
        #btn-fire:active { background: rgba(255, 0, 0, 0.6); }
        #hud { position: absolute; top: 10px; left: 10px; color: white; text-shadow: 1px 1px 2px black; pointer-events: none; }
    </style>
</head>
<body>
    <div id="game-container"></div>
    <div id="ui-layer">
        <div id="hud"><div id="hud-ammo">Ammo: 0</div><div id="hud-score">Score: 0</div><div id="hud-time">Time: 60</div></div>
        <div id="dpad">
            <div id="btn-up" class="btn">↑</div><div id="btn-down" class="btn">↓</div>
            <div id="btn-left" class="btn">←</div><div id="btn-right" class="btn">→</div>
        </div>
        <div id="btn-fire" class="btn">FIRE</div>
    </div>

    <script>
        class MyGame extends Phaser.Scene {
            constructor() {
                super();
                this.playerSpeed = 200;
                this.enemySpeed = 100;
                this.playerAmmo = 50;
                this.maxPlayerAmmo = 100;
                this.playerScore = 0;
                this.gameTimer = 60;
                this.gameOver = false;
                this.inputs = { up: false, down: false, left: false, right: false };
                this.lastFacing = 0; 
            }


            preload() {
                // 修改這裡：直接填入你的 GitHub Raw URL
                // 記得確認 frameWidth 和 frameHeight 是否真的是 32x32
                this.load.spritesheet('player', 
                    'https://raw.githubusercontent.com/darkbearlab/gunFightSurvivor/refs/heads/main/player_front.png', 
                    { frameWidth: 32, frameHeight: 32 }
                );
            
                // 其他色塊繼續保留 (除非你也有圖了)
                this.createTexture('enemy', 24, 24, 0xff0000);
                this.createTexture('bullet', 10, 10, 0xffff00);
                this.createTexture('ammoPack', 16, 16, 0x00ffff);
            }
            
            createTexture(key, w, h, color) {
                const g = this.make.graphics({ x: 0, y: 0, add: false });
                g.fillStyle(color, 1); g.fillRect(0, 0, w, h); g.generateTexture(key, w, h);
            }

            create() {
                this.physics.world.setBounds(0, 0, 2000, 2000);
                
                // [修改點 2] 建立動畫
                // 我們定義一個叫 'walk' 的動畫，使用第 0, 1, 2, 3 格
                this.anims.create({
                    key: 'walk', 
                    frames: this.anims.generateFrameNumbers('player', { start: 0, end: 3 }), 
                    frameRate: 10, // 每秒播 10 格 (速度感)
                    repeat: -1     // -1 代表無限循環播放
                });

                this.player = this.physics.add.sprite(1000, 1000, 'player');
                this.player.setCollideWorldBounds(true);
                // 稍微放大一點，不然 32px 在手機上可能有點小
                this.player.setScale(1.5); 

                this.cameras.main.startFollow(this.player, true, 0.05, 0.05);
                this.cameras.main.setBounds(0, 0, 2000, 2000);

                this.enemies = this.physics.add.group({ classType: Enemy, runChildUpdate: true });
                this.bullets = this.physics.add.group({ classType: Bullet, runChildUpdate: true });
                this.ammoPacks = this.physics.add.group();

                this.physics.add.overlap(this.bullets, this.enemies, this.hitEnemy, null, this);
                this.physics.add.overlap(this.player, this.enemies, this.playerHitByEnemy, null, this);
                this.physics.add.overlap(this.player, this.ammoPacks, this.collectAmmo, null, this);

                this.time.addEvent({ delay: 1500, callback: this.spawnEnemy, callbackScope: this, loop: true });
                this.time.addEvent({ delay: 5000, callback: this.spawnAmmoPack, callbackScope: this, loop: true });
                this.timerEvent = this.time.addEvent({ delay: 1000, callback: this.updateTimer, callbackScope: this, loop: true });

                this.bindHtmlControl('btn-up', 'up');
                this.bindHtmlControl('btn-down', 'down');
                this.bindHtmlControl('btn-left', 'left');
                this.bindHtmlControl('btn-right', 'right');
                
                const fireBtn = document.getElementById('btn-fire');
                const triggerFire = (e) => { e.preventDefault(); this.shootBullet(); };
                fireBtn.addEventListener('mousedown', triggerFire);
                fireBtn.addEventListener('touchstart', triggerFire);

                this.keys = this.input.keyboard.addKeys('W,A,S,D,UP,DOWN,LEFT,RIGHT');
                this.updateHud();
            }

            bindHtmlControl(id, prop) {
                const btn = document.getElementById(id);
                const start = (e) => { e.preventDefault(); this.inputs[prop] = true; };
                const end = (e) => { e.preventDefault(); this.inputs[prop] = false; };
                btn.addEventListener('mousedown', start); btn.addEventListener('mouseup', end);
                btn.addEventListener('touchstart', start); btn.addEventListener('touchend', end);
                btn.addEventListener('mouseleave', end);
            }

            update() {
                if (this.gameOver) return;
                this.handleMovement();
            }

            handleMovement() {
                this.player.setVelocity(0);
                let vx = 0, vy = 0;

                const up = this.inputs.up || this.keys.W.isDown || this.keys.UP.isDown;
                const down = this.inputs.down || this.keys.S.isDown || this.keys.DOWN.isDown;
                const left = this.inputs.left || this.keys.A.isDown || this.keys.LEFT.isDown;
                const right = this.inputs.right || this.keys.D.isDown || this.keys.RIGHT.isDown;

                if (left) vx = -this.playerSpeed;
                else if (right) vx = this.playerSpeed;
                if (up) vy = -this.playerSpeed;
                else if (down) vy = this.playerSpeed;

                this.player.setVelocity(vx, vy);

                // [修改點 3] 動畫控制邏輯
                if (vx !== 0 || vy !== 0) {
                    this.player.body.velocity.normalize().scale(this.playerSpeed);
                    
                    // 只要有移動，就播放 'walk' 動畫
                    // ignoreIfPlaying: true 表示如果已經在播這個動畫，不要重頭開始，讓它順順播
                    this.player.anims.play('walk', true);

                    if (Math.abs(vx) > Math.abs(vy)) {
                        this.lastFacing = (vx > 0) ? 0 : 180;
                        // 如果有左右方向的圖，這裡可以用 this.player.setFlipX(vx < 0)
                    } else {
                        this.lastFacing = (vy > 0) ? 90 : -90;
                    }
                    // 注意：我不使用 setAngle，因為你的圖片是「正視圖」，旋轉90度會變躺著走
                    // 如果你要真正的「面向」，你需要上下左右四組圖片
                } else {
                    // 沒移動時，停止動畫
                    this.player.anims.stop();
                    
                    // (選用) 設定停在第 0 格 (站立狀態)
                    // this.player.setFrame(0); 
                }
            }

            shootBullet() {
                if (this.gameOver || this.playerAmmo <= 0) return;
                const bullet = this.bullets.get(this.player.x, this.player.y);
                if (bullet) {
                    this.playerAmmo--;
                    this.updateHud();
                    bullet.fire(this.player.x, this.player.y, this.lastFacing);
                }
            }
            
            // ... (以下為與之前相同的碰撞、生成邏輯，省略以節省篇幅) ...
            
            hitEnemy(bullet, enemy) {
                bullet.destroy();
                const damage = Phaser.Math.Between(1, 2);
                enemy.takeDamage(damage);
                const txt = this.add.text(enemy.x, enemy.y - 20, damage, { fontSize: '16px', fill: '#fff' }).setOrigin(0.5);
                this.tweens.add({ targets: txt, y: enemy.y - 50, alpha: 0, duration: 500, onComplete: () => txt.destroy() });
                if (enemy.health <= 0) {
                    enemy.destroy();
                    this.playerScore += 10;
                    this.updateHud();
                }
            }
            playerHitByEnemy() {
                if (this.gameOver) return;
                this.gameOver = true;
                this.physics.pause();
                alert('遊戲結束！你被抓住了。');
                location.reload();
            }
            collectAmmo(player, pack) {
                pack.destroy();
                this.playerAmmo = Math.min(this.playerAmmo + 10, this.maxPlayerAmmo);
                this.updateHud();
            }
            spawnEnemy() {
                if (this.gameOver) return;
                const r = 500; const angle = Phaser.Math.Between(0, 360);
                const x = this.player.x + Math.cos(angle) * r;
                const y = this.player.y + Math.sin(angle) * r;
                if (x > 0 && x < 2000 && y > 0 && y < 2000) {
                    const enemy = this.enemies.get(x, y);
                    if (enemy) enemy.init(this.player, this.enemySpeed);
                }
            }
            spawnAmmoPack() {
                if (this.gameOver) return;
                this.ammoPacks.create(Phaser.Math.Between(100, 1900), Phaser.Math.Between(100, 1900), 'ammoPack');
            }
            updateTimer() {
                if (this.gameOver) return;
                this.gameTimer--;
                this.updateHud();
                if (this.gameTimer <= 0) {
                    this.gameOver = true; this.physics.pause();
                    alert('時間到！生存成功！\n分數: ' + this.playerScore); location.reload();
                }
            }
            updateHud() {
                document.getElementById('hud-ammo').innerText = `Ammo: ${this.playerAmmo}/${this.maxPlayerAmmo}`;
                document.getElementById('hud-score').innerText = `Score: ${this.playerScore}`;
                document.getElementById('hud-time').innerText = `Time: ${this.gameTimer}`;
            }
        }

        class Enemy extends Phaser.Physics.Arcade.Sprite {
            constructor(scene, x, y) { super(scene, x, y, 'enemy'); }
            init(player, speed) {
                this.player = player; this.speed = speed; this.health = 2;
                this.setActive(true).setVisible(true); this.body.reset(this.x, this.y);
            }
            takeDamage(amount) {
                this.health -= amount; this.setTint(0xff8888);
                this.scene.time.delayedCall(100, () => this.clearTint());
            }
            update() {
                if (!this.active || !this.player) return;
                this.scene.physics.moveToObject(this, this.player, this.speed);
            }
        }

        class Bullet extends Phaser.Physics.Arcade.Sprite {
            constructor(scene, x, y) { super(scene, x, y, 'bullet'); }
            fire(x, y, angle) {
                this.body.reset(x, y); this.setActive(true).setVisible(true); this.setAngle(angle);
                this.scene.physics.velocityFromAngle(angle, 400, this.body.velocity);
                this.scene.time.delayedCall(2000, () => this.destroy());
            }
        }

        const config = {
            type: Phaser.AUTO,
            scale: { mode: Phaser.Scale.RESIZE, parent: 'game-container', autoCenter: Phaser.Scale.CENTER_BOTH },
            physics: { default: 'arcade', arcade: { debug: false } },
            scene: MyGame
        };

        const game = new Phaser.Game(config);
    </script>
</body>
</html>
